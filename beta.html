<!DOCTYPE html>
<html>
  <head>
    <title>IEEE-754 Float 64 library.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-mobile-web-app-title" content="FL64">
    <link rel="apple-touch-icon" href="/docs/bg/icon.png">
    <meta property="og:image" content="https://opengraph.githubassets.com" />
    <meta property="og:url" content="https://recoskie.github.io/Fl64/beta.html" />
    <meta property="og:title" content="FL64: Vector number ratios (Beta tool)" />
    <meta property="og:description" content="FL64 is a math tool for analyzing or creating numbers. FL64 is also a library of functions that can be called from other webpages for use in your own projects." />
    <link rel="canonical" href="https://recoskie.github.io/Fl64/beta.html" />
    <link rel="manifest" href="manifest.json">
    <style type="text/css">
      <!--
        body
        {
          background-color: aqua;
          color:black;
          background-image: url(docs/bg/bg.jpg);
          background-repeat: no-repeat;
          background-size: cover;
          -moz-background-size: cover;
          -webkit-background-size: cover;
          margin: 0; 
          padding: 0; 
          font-family: Arial, sans-serif; 
        }
        input[type=button]
        {
          background-color: rgba(0, 200, 255, 0.50);
        }
        input[type=text]
        {
          background-color: rgba(255, 255, 255, 0.50);
        }
        table
        {
          background-color: rgba(200,200,200,0.50);
        }
        .page
        {
          background-color: rgba(200,200,200,0.50);
          width: 100%; height: 100vh; max-height: 100vh;
          overflow-y: scroll;
        }
        @media (max-width: 600px) { h1 { font-size: 24px; } }
      -->
    </style>
    <script src="FL64.js" type="text/javascript"></script>
    <script src="https://recoskie.github.io/AI-Matrix/AI-Mat.js" type="text/javascript"></script>
    <script type="text/javascript">

      //Number of parts to compute vectors to, or split number to if possible.

      var parts = 20;

      /***********************************************************************************
      Prototype vector additions to FL64.
      ***********************************************************************************/
    
      vect.prototype.val = vect.prototype.pv = vect.prototype.px = vect.prototype.py = new Number(NaN);
      vect.prototype.v = [];

      function vect(v)
      {
        if(AI_Mat == undefined) { throw("AI Matrix library must be loaded to use Vector additions."); }
        
        //Create copy of the vector.
        
        if(v.v != undefined)
        {
          this.val = NaN; this.px = v.px; this.py = v.py; this.v = []; for(var i=0;i < v.v.length;this.v[i] = v.v[i], i++);
          for(var i=0;i < v.val.length;this.val.split(v.val.a[i],1), i++);
        }
        
        //Else create an new vector.
        
        else
        {
          if(arguments.length == 0){ throw("Expected vector input type!"); } v = Array.prototype.slice.call(arguments);
          if(v.length == 1){ v = v.toString(); if(v.indexOf(",") > 0) { v = v.split(","); } else { throw("Vectors can not be one value in length."); } }
        
          //Init and construct vector data type.
        
          this.v = []; for(var i = 0;i < v.length;i++){ this.v[i] = parseInt(v[i]); if(isNaN(this.v[i])){ throw("Only Numbers are allowed in an vector."); } };
          
          //Sing value of all values in vector must not match.

          for(var i = 0, c = this.v[0] < 0, ct = false; i < this.v.length && !ct; i++){ ct = ((c ? -this.v[i] : this.v[i]) < 0); } if(!ct){ this.v.push(-this.v.pop()) }

          AI_Mat.adjustSMat(this.v.length-1); this.val = NaN;

          //Vectors 2 in length can be approximated directly.

          if(this.v.length == 2){ this.pv = (this.px = -this.v[1]) / (this.py = this.v[0]); this.px = -this.px; return(this); }

          //Make an backup of this vectors initial values.

          var vc = []; for(var i = 0; i < this.v.length; vc[i] = this.v[i++]);

          //Approximate value of vector as an float number, and best fract.

          this.pv = 0; this.split(2); while((this - this.pv) != 0){ this.pv = this+0; this.split(); }

          this.px = this.val.fx[this.val.length-1]; this.py = this.val.fy[this.val.length-1];

          //Reset vector.

          this.v = vc; this.val = new Number(NaN);
        }
      }

      /***********************************************************************************
      Calculate int=A from summed vector combination.
      Input n is number of parts. If n is undefined split to one part.
      ***********************************************************************************/

      vect.prototype.split = function(n)
      {
        if(this.v[0] == 0){ return(this); }

        var r = [], a = -1, n = n || 1; var c = false, ct = true;
  
        for( var i = 0; i < n; i++ )
        {
          a = -1; r = this.v;
          
          while(ct && a < 1000)
          {
            ++a; this.v = r; r = []; for(var s=this.v.length-1,i1=s;i1>=0;i1--)
            {
              r[s-i1]=0; for(var i2=s;i2>=0;i2--) { r[s-i1]+=(AI_Mat.SMat[i2][i1]||0)*this.v[s-i2]; }
            }

            c = r[0] < 0; ct = false; for(var i2 = 0; i2 < r.length && !ct; i2++){ ct = ((c ? -r[i2] : r[i2]) <= 0); }
          }

          if(a >= 1000){ return(this); }

          this.val = this.val.split(a,1); this.v = this.v.reverse();

          if(a == 0 && this.val.length > 1) { return(this); } ct = true;
        }

        return(this);
      }

      /***********************************************************************************
      Show the complete work of the split operation.
      ***********************************************************************************/      

      function splitWork(vect,showWork,firstStep,curParts)
      {
        var t = []; for(var i = 0;i < vect.length;t[i] = vect[i++]); vect = t; if(vect[0] == 0){ return(this); }

        var r = [], curParts = curParts || [], a = -1, n = n || 1; var c = false, ct = true;

        var str = (curParts.length == 0 ? "<div style='background-color: rgb(68, 157, 43);'>" : ""); while(showWork > 0)
        {
          a = -1; r = vect; while(ct && a < 1000)
          {
            ++a; vect = r; r = []; for(var s=vect.length-1,i1=s;i1>=0;i1--)
            {
              r[s-i1]=0; for(var i2=s;i2>=0;i2--) { r[s-i1]+=(AI_Mat.SMat[i2][i1]||0)*vect[s-i2]; }
            }

            c = r[0] < 0; ct = false; for(var i2 = 0; i2 < r.length && !ct; i2++){ ct = ((c ? -r[i2] : r[i2]) <= 0); }

            //Show the resulting vector values with a button that allows the user to see the calculation.

            if(!firstStep) { str += "<div>Vect = " + vect + "<input type='button' value='Show steps' onclick='splitStepShow(this,["+ vect +"])'></div><br />"; }

            //Else show the first step if firstStep is active.

            else { str += splitStep(vect) + "This operation is repeated till all numbers are negative or positive in the vector.<br /><br />"; firstStep = false; }
          }

          str += "Vect = " + r + "<br />";

          if(a == 1000) { str = ""; } if(vect[vect.length-1] == 0 || a == 1000 || (a == 0 && curParts.length > 1)) { str += "<br />Vector zero terminated."; }

          else
          {
            curParts.push(a);
          
            str += "<br />All values in this vector are summed to all positive, or negative after "+ a +" times.<br /><br />";
            str += "This makes the parts to our number ratio " + curParts + "...<br /><br />";
            str += "We move back to the previous vector value " + vect + " and reverse it's order to find the next reciprocal part.<br /><br />";

            vect = vect.reverse(); ct = true;
            
            if(showWork == 1) { str += "<div>Would you like to see the steps to find the next parts. <input type='button' value='Show next part steps' onclick='splitWorkStep(this,["+vect+"],["+curParts+"])'></div>"+ (curParts.length != 1 ? "" : "</div>"); }
          }
        
          showWork -= 1;
        }

        return(str);
      }

      function splitWorkStep(e,vect,parts) { e.parentElement.outerHTML = splitWork(vect,1,false,parts); }

      /***********************************************************************************
      Show work to sum the next vector combination.
      ***********************************************************************************/

      function splitStep(state)
      {
        var r = state, mat = [];

        var str = "Vect = " + state + "<br /><br /><div style='background-color: rgb(68, 43, 157);'>To compute the next vector sums, we begin with the following matrix.<br /><br /><table border='1'>";

        for(var s=state.length-1,i1=s;i1>=0;i1--)
        {
          str += "<tr><td>row "+String.fromCharCode(0x41+mat.length)+"</td>"

          var t = []; for(var i2=s;i2>=0;i2--) { str+="<td>" + (AI_Mat.SMat[i2][i1]||0) + "</td>"; t.push((AI_Mat.SMat[i2][i1]||0)); } mat.push(t);

          str += "</tr>";
        }

        str += "</table><br />"; sums = []; for(var i1 = 0;i1 < mat.length;i1++)
        {
          str += "We multiply row " + String.fromCharCode(0x41+i1) + " = " + mat[i1] + " with our current vector values " + state + " and add them together.<br /><br />";

          sums[i1] = 0; for(var i2=0;i2<mat[i1].length;i2++) { str += state[i2] + "&times;" + mat[i1][i2] + (i2 < (mat[i1].length - 1) ? " + " : ""); sums[i1] += state[i2] * mat[i1][i2];}

          str += " = " + sums[i1] + "<br /><br />";
        }

        return(str + "This makes our new vector " + sums + "</div><br />");
      }

      function splitStepShow(sect, state) { sect.parentElement.innerHTML = splitStep(state); }

      /***********************************************************************************
      Show how to add the parts back into an number.
      ***********************************************************************************/

      function addParts(v,n)
      {
        var t1 = v.val.a[0], t2 = "", str = "<div style='background-color: rgb(68, 43, 157);'>" + t1 + " = " + v.val.a[0] + "<br /><br />", n = Math.min(n || v.val.a.length, v.val.a.length);
        
        for(var i = 1;i < n;i++) { t1 = t1 + "+1&div;"; str += t1 + v.val.a[i] + t2 + " = " + v.val.calc(0,i) + "<br />" + (i < (n-1) ? "<br />" : ""); t1 += "(" + v.val.a[i] + ""; t2 += ")"; }

        return(str + (i < v.val.length ? "<div><input type='button' value='Add next part' onclick='addNextPart(this,"+(n+1)+",["+v.val.a+"]);' /></div>" : "") + "</div>");
      }

      function addNextPart(e,n,parts)
      {
        var t = new Number(NaN).split(t1 = parts[0]), o = "", t2 = ""; for(var i = 1;i < n;i++){ t = t.split(parts[i]); t1 = t1 + "+1&div;"; o = t1 + parts[i] + t2 + " = "; t1 += "(" + parts[i] + ""; t2 += ")"; }

        e.parentElement.innerHTML = "<br />" + o + t.calc() + (i < parts.length ? "<div><input type='button' value='Add next part' onclick='addNextPart(this,"+(i+1)+",["+parts+"]);' /></div>" : "");
      }

      /***********************************************************************************
      Demonstrate how reciprocal parts are added back into converging fractions.
      ***********************************************************************************/

      function addPartsFract(parts,n)
      {
        var str = "To add parts into fractions, the Numerator = 0 + 1 &times; part, and the Denominator = 1 + 0 &times; part.<br /><br />"

        str += "The values in the table are colored to show how we multiply the parts and move the values to the following line times the next added part, making Numerator÷Denominator = value per added part.<br /><br />";

        str += "<table border='1'><tr><td>Numerator</td><td>Denominator</td><td>Add part</td><td>Fraction</td></tr>";

        n = Math.min(n || parts.length, parts.length); for(var i = 0, fx = 1, tx = 0, fy = 0, ty = 1, c = false;i<n;i++)
        {
          str += "<tr><td>" + (i > 0 ? "<p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + tx + "</p>" : tx);
          str += " + <p style='display:inline-block;background-color:"+(c ? "#FF0000" : "#00FF00")+";'>" + fx + "</p>&times;" + parts[i] + "";
          str += " = <p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + (fx = tx + (tx = fx) * parts[i]) + "</p></td>";

          str += "<td>" + (i > 0 ? "<p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + ty + "</p>" : ty);
          str += " + <p style='display:inline-block;background-color:"+(c ? "#FF0000" : "#00FF00")+";'>" + fy + "</p>&times;" + parts[i] + "";
          str += " = <p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + (fy = ty + (ty = fy) * parts[i]) + "</p></td>";
  
          str += "<td>" + parts[i] + "</td><td>" + fx + "&div;" + fy + " = " + fx/fy + "</td></tr>";

          if(c) { c = false; } else { c = true; }
        }

        return(str + (n < parts.length ? "<tr><td colspan='4'><input type='button' value='Add next part' onclick='addNextPartFract(this,["+parts+"],["+fx+","+tx+","+fy+","+ty+","+i+","+c+"]);' /></td></tr>" : "") + "</table>");
      }

      function addNextPartFract(e,parts,state)
      {
        var fx = state[0], tx = state[1], fy = state[2], ty = state[3], i = state[4], c = state[5], btn = false;
        
        e = e.parentElement.parentElement; if( state[4] < (parts.length-1) ) { btn = e.parentElement.appendChild(document.createElement("tr")); }

        var str = "<tr><td>" + (i > 0 ? "<p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + tx + "</p>" : tx);
        str += " + <p style='display:inline-block;background-color:"+(c ? "#FF0000" : "#00FF00")+";'>" + fx + "</p>&times;" + parts[i] + "";
        str += " = <p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + (fx = tx + (tx = fx) * parts[i]) + "</p></td>";

        str += "<td>" + (i > 0 ? "<p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + ty + "</p>" : ty);
        str += " + <p style='display:inline-block;background-color:"+(c ? "#FF0000" : "#00FF00")+";'>" + fy + "</p>&times;" + parts[i] + "";
        str += " = <p style='display:inline-block;background-color:"+(c ? "#00FF00" : "#FF0000")+";'>" + (fy = ty + (ty = fy) * parts[i]) + "</p></td>";
  
        str += "<td>" + parts[i] + "</td><td>" + fx + "&div;" + fy + " = " + fx/fy + "</td></tr>";

        if(c) { c = false; } else { c = true; }
        
        e.innerHTML = str; if(btn){ btn.innerHTML = "<tr><td colspan='4'><input type='button' value='Add next part' onclick='addNextPartFract(this,["+parts+"],["+fx+","+tx+","+fy+","+ty+","+(i+1)+","+c+"]);' /></td></tr>"; }
      }

      /***********************************************************************************
      Show how we get the parts of an number.
      ***********************************************************************************/
      
      function getParts(v,n)
      {
        var str = "";for(var i = 0, r = v.reValue();i < n;i++)
        {
          str += "<div style='background-color: rgb(68, 43, 157);'>The value before the decimal point of " + r + " is " + (r & -1) + ", which makes our reciprocal parts " + (v.length != 0 ? v.a + "," : "") + (r&-1) + "...<br />";v = v.split();
          r -= r&-1; str += "We take away the value before the decimal point, leaving " + r + ".<br />";
          if(v == 0)
          {
            if(r != 0)
            {
              str += "The remaining value " + r + " can not be divided to any more parts as we have reached the end of accuracy of a float64 number.";
            }
            else
            {
              str += "The remaining value " + r + " can not be divided to any more parts.";
            }

            return(str + "</div>");
          }
          else { str += "We divide the value into one to find the next reciprocal part 1&div;"+r+" = " + (r=1/r) + "<br /><br />"; }
        }

        return(str + (v != 0 ? "<div><input type='button' value='Find next part' onclick='getNextPart(this,"+v.r[0]+",["+v.a+"])'></div>" : "") + "</div>");
      }

      function getNextPart(e,v,parts)
      {
        for(var i = 0;i < parts.length; v = v.split(), i++); var r = v.reValue();

        var str = "The value before the decimal point of " + r + " is " + (r & -1) + ", which makes our reciprocal parts " + (v.length != 0 ? v.a + "," : "") + (r&-1) + "...<br />";v = v.split();
        r -= r&-1; str += "We take away the value before the decimal point, leaving " + r + ".<br />";
        if(v == 0)
        {
          if(r != 0)
          {
            str += "The remaining value " + r + " can not be divided to any more parts as we have reached the end of accuracy of a float64 number.<br /><br />";
          }
          else
          {
            str += "The remaining value " + r + " can not be divided to any more parts.<br /><br />";
          }
        }
        else { str += "We divide the value into one to find the next reciprocal part 1&div;"+r+" = " + (r=1/r) + "<br /><br />"; }

        e.parentElement.innerHTML = str + (v != 0 ? "<div><input type='button' value='Find next part' onclick='getNextPart(this,"+v.r[0]+",["+v.a+"])'></div>" : "");
      }

      /***********************************************************************************
      Remove int=A from summed vector combination.
      Input n is number of parts. If n is undefined removes one part.
      ***********************************************************************************/

      vect.prototype.remove = function(n)
      {
        var r = [], a = 0, n = Math.min(n || 1, this.val.length); for( var i = 0; i < n; i++ )
        {
          a = this.val.a[this.val.length-1]; this.v = this.v.reverse(); while(a > 0)
          {
            a--; r = []; for(var s=this.v.length-1,i1=s;i1>=0;i1--)
            {
              r[s-i1]=0; for(var i2=s;i2>=0;i2--) { r[s-i1]-=(AI_Mat.SMat[i2][i1]||0)*this.v[s-i2]; r[s-i1]=-r[s-i1]; }

              if(i1%2 == 1){ r[s-i1]=-r[s-i1]; }
            }
            this.v = r;
          }
    
          this.val=this.val.remove();
        }
        
        return(this);
      }

      /***********************************************************************************
      Vector to number of dimensions.
      ***********************************************************************************/

      vect.prototype.expand = function(dif) { dif = dif || 0; AI_Mat.adjustSMat(this.v.length); this.v.push(dif,(this.v.pop()-dif)*this.pv); return(this); }

      vect.prototype.combine = function() { if(this.v.length > 2) { this.v.push((this.v.pop()+this.v.pop()*this.pv)/this.pv); } return(this); }

      /***********************************************************************************
      Change the vectors dimensions.
      ***********************************************************************************/

      vect.prototype.dif = function()
      {
        var t = [(arguments[0]||0)+""]; if(arguments.length > 1) { t = Array.prototype.slice.call(arguments); }
        else if(t[0].toString().indexOf(",") > 0) { t = t[0].split(","); }
        var v = [];for(var i = 0;i < this.v.length - 1; i++){if(isNaN(v[i] = parseInt(t[i]||0))){throw("Only numbers are allowed!");}}
        v[0] = v[0] || 1; for(var i = 0;i < v.length;i++){ this.v[i+1] += this.pv * (this.v[i] - v[i]); this.v[i] = v[i]; } return(this);
      }

      /***********************************************************************************
      Find the vector ratio.
      ***********************************************************************************/

      function findVect(n,bv)
      {
        var vt = bv ? bv : [1,0,0], match = true, matches = -1, mPos = -1, temp = null, oVect = [];
        var str = "<div id='result'><table border='1'><tr><td>Added part</td><td>Vector</td><td>Vector ratio</td><td>Detailed steps</td></tr>";

        for(var i = 0;i < (n.length-1); i++)
        {
          var fr = n.calcF(0,i); var dv = new vect(fr.y,fr.x); for(var i2 = 1; i2 < vt.length; dv = dv.expand(), i2++);

          dv = dv.dif(vt); dv.v.push(Math.round(dv.v.pop())); for(var i2 = 0;i2 < dv.v.length;oVect[i2] = dv.v[i2++]);
          
          dv = dv.split(i+2); match = true; for(var i2 = 0; i2 < (i+2) && match; i2++) { match = n.a[i2] == dv.val.a[i2]; }
          
          if(match){ matches++; if(mPos < 0 && matches >= 1){ mPos = i; } }else{ matches = -1; }
  
          str += "<tr"+(match ? " style='background-color:green;'" : " style='background-color:red;'")+"><td>" + n.a.slice(0,i+1) + "</td><td>" + fr.y + "," + fr.x + "</td><td>" + oVect + "</td><td><input type='button' value='show steps' onclick='showFindVect(this,[" + n.a.slice(0,i+1) + "],[" + vt + "],[" + fr.y + "," + -fr.x + "])' /></td></tr>";
        }

        str += "</table><br />";

        if(mPos > 0)
        {
          str += "<div style='background-color:rgba(128,128,128,80);'>As we can see the vector ratio repeats its self once we have added enough receptacle parts in order to compute the ratio.<br /><br />";
          str += "We only need " + n.a.slice(0,mPos+1) + " parts to find where the vector ratio matches for our value.<br /><br />";
          str += "The smallest fraction or value we can use to compute the value " + n.r[0] + " back into its ratio is " + n.calcF(0,mPos+1).toString() + " = " + n.calc(0,mPos+1) + "<br /><br />";
          str += "Any smaller or fewer parts we would not be able to find this numbers ratio as we need the  next added part to come out to the previous vector at least once.</div>";
        }
        else
        {
          str += "<div style='background-color:rgba(255,128,128,80);'>The resulting computed vector ratio from added parts does not match at least twice meaning it can not be solved.<br /><br />";
          str += "<div style='background-color:rgba(128,128,128,80);'>An vector of 1,2,-99,180 creates value 1.708792264021897. We can convert the value to converging factions and reduce the vector.<br /><br />";
          str += "We do this by expanding the fraction one column higher than what we want to reduce the first three columns to 1,2,-99.<br /><br />";
          str += "The last value is rounded off making 180 when enough parts are added into a converging fraction as a vector<br /><br />";
          str += "In theory it is possible to build an reduction algorithm that expand the converging fractions and finds the most reduced values for the columns to compute your number.<br /><br />";
          str += "For the time being while this algorithm is in beta development, you can guess at what the first columns reduce into causing the last column to round to the proper value when reduced.<br /><br />";
          str += "In the case of the vector of 1,2,-99,180 creates value 1.708792264021897 you would enter the values 1,2,-99 then hit use dif. The last column should automatically round to 180 and match the values ratio.</div><br /><br />";
          str += "Vector possibly begins with <input type='text' value='"+vt+"' id='dif' /><input type='button' value='use dif' onclick='findVectDif(["+n.a+"])' /></div></div>";
        }

        return(str);
      }

      /***********************************************************************************
      Run find vect with new differences.
      ***********************************************************************************/

      function findVectDif(parts)
      {
        var dif = document.getElementById("dif").value.split(","); for(var i = 0;i<dif.length;i++){ dif[i] = parseInt(dif[i],10); if(isNaN(dif[i])){ alert("Bad vector input!"); return; } }

        if(dif.length == 0){ alert("No differences given to use."); }

        var n = new Number(NaN); for(var i=0;i<parts.length;n=n.split(parts[i++])); document.getElementById("result").innerHTML = findVect(n,dif);
      }

      /***********************************************************************************
      Change the vectors dimensions. Show work version.
      ***********************************************************************************/

      function showFindVect(e,parts,dif,vect)
      {
        var r1 = document.createElement("tr"), r2 = document.createElement("td"), v = 0; r2.setAttribute("colspan","4"); r2.style = "word-wrap:break-word;overflow-wrap:break-word;"; r1.appendChild(r2);

        e.parentElement.parentElement.parentNode.insertBefore(r1, e.parentElement.parentElement.nextSibling); e.parentElement.innerHTML = "Expanded"; e = r2;
        
        e.innerHTML = "The vector " + vect + " computes to the following receptacle parts " + parts + " when summed. It then terminates to all zeros.<br /><br />";

        e.innerHTML += "The vector " + vect + " should sum to the value " + -vect[1] + "&div;" + vect[0] + " = " + (v=(-vect[1] / vect[0])) + " <br /><br />";

        e.innerHTML += "To expand this vector ratio to " + dif.length + " columns, we multiply both sides by them selves to how many columns we want.<br /><br />";

        var s1 = vect[0] + "", z = "", s2 = vect[1] + "", t = vect.pop();

        for(var i = 1;i < dif.length;i++){ vect.push(0); s1 += "&times" + vect[0]; z += ",0"; s2 += "&times" + t; }

        vect[0]**=dif.length; vect.push(dif.length % 2 == 0 ? -(t**dif.length) : t**dif.length);

        e.innerHTML += "This makes our new vector columns " + s1 + z + "," + s2 + "<br /><br />";

        e.innerHTML += "This makes our vector " + vect + " which also computes to the same value and terminates to all zero.<br /><br />";

        e.innerHTML += "The final step is to change the vector columns to reduce the vector.<br /><br />";

        var str = ""; for(var i = 0;i < dif.length;i++) { str += vect[i+1] + "+" + v + "&times" + "(" + vect[i] + " - " + dif[i] + ")"; vect[i+1] += v * (vect[i] - dif[i]); str += " = " + vect[i+1] + "<br />"; vect[i] = dif[i]; }

        e.innerHTML += str + "<br />This gives us the following vector " + vect + " in which we round off the remaining value at the last column.<br /><br />";

        e.innerHTML += "For now we know the vector begins with " + dif + ", and by applying these sums lines up the last column to " + vect[vect.length-1] + " automatically.<br /><br />";

        e.innerHTML += "Currently we know it is possible to compute number ratios back using the layed out methods, and transformations.<br /><br />";
        
        e.innerHTML += "As for what the fastest reduction algorithm is to change the vector back from it's expanded forum to smallest ratio per column is not yet known.";
      }

      /***********************************************************************************
      Convert numbers or fraction to 1D vector.
      ***********************************************************************************/

      vect.prototype.toVect = function() { var f = this.val.calcF(); return(new vect(f.y,f.x)); }

      Number.prototype.toVect = function() { var f = this.getFract(); return(new vect(f.y,f.x)); }

      Fract.prototype.toVect = function() { var f = this.calcF(); return(new vect(f.y,f.x)); }

      /***********************************************************************************
      Basic functions for displaying a vector or adding vector to other float values when doing math.
      ***********************************************************************************/

      vect.prototype.valueOf = function() { return(this.val.calc()); }

      vect.prototype.toString = function() { var o = "Vect="+this.v+"\r\n\r\n"; for(var i = 0;i < this.val.length;i++) { o+="x"+i+"=A:"+this.val.a[i]+", B:1\r\n"; } return(o+(this+0)); }

      /***********************************************************************************
      Analyze users input.
      ***********************************************************************************/
      
      function getInput()
      {
        n = document.getElementById("iv").value; parts = document.getElementById("pt").value;
      
        var bv = [], out = document.getElementById("out"), isVect = false;

        if(isVect = n.indexOf(",") > 0) { n = n.split(","); for(var i1=0;i1<n.length;i1++) { n[i1] = Math.abs(parseInt(n[i1],10)); if(isNaN(n[i1])){ alert("Bad vector input!"); return; } } }
        else { n = parseFloat(n); if(isNaN(n)) { alert("Bad number input!"); return; } }
        parts = parseInt(parts, 10); if(isNaN(parts)) { alert("Enter a number value for the number of parts you wish to split the number or calculate the vector to!"); return; }
        
        out.innerHTML = "";

        if(isVect)
        {
          //Check if vector is an root of a number.

          bv = n.slice(0,n.length - 1); out.innerHTML += "<h1>Vector pre-analysis</h1>";

          var isRoot = true; for(var i = 1; i < n.length - 1 && isRoot; i++){ if(n[i]!=0){ isRoot = false; } }

          //If the vector is the root of an number.

          var type = Math.abs(n[n.length - 1]), isDiv = Math.abs(n[0]) != 1, calc = (Math.abs(n[n.length-1])/Math.abs(n[0]))**(1/(n.length-1));
          
          if(isDiv){ type = "(" + type + "&div;" + Math.abs(n[0]) + ")"; }

          if(n.length == 3){ type = "&radic;" + type; } else if(n.length == 4){ type = "&#8731;" + type; }
          else if(n.length == 5){ type = "&#8732;" + type; } else if(n.length != 2){ type = type + " to the root of " + (n.length-1); }

          out.innerHTML += "The vector " + n + " ratio is " + n.length + " numbers which is to the root of " + n.length + "-1=" + (n.length-1) + " at it's last column.<br /><br />";
          if(n.length == 2){ out.innerHTML += "Since this vector ratio is to the root of 1 than it is the value of its last column " + Math.abs(n[n.length-1]) + ".<br /><br />"; }
          else{ out.innerHTML += "This makes the vector ratio " + Math.abs(n[n.length-1]) + " to the root of " + (n.length-1) + ".<br /><br />"; }
          if(Math.abs(n[0]) != 1)
          {
            out.innerHTML += "Since the first value in the vector is " + Math.abs(n[0]) + " this makes the summed sequence an " + Math.abs(n[0]) + "th of its size.<br /><br />";
            out.innerHTML += "We compute this by dividing our vector last column to the root of value.<br /><br />";
          }

          if(isRoot)
          {
            out.innerHTML += "The vector " + n + " should be " + type + " = " + calc + " when summed.";
          }
          else
          {
            out.innerHTML += "The vector " + n + " may be close to " + type + " = " + calc + " when summed, or could be very different.<br /><br />";
            out.innerHTML += "An vector like " + n + " is similar to what the ratio of PI is 3.1415926535 which is not the root of any number, but can be computed as a series of roots, or as a vector ratio.";
          }

          out.innerHTML += "<h1>Summing the vector ratio</h1>";

          var v = new vect(n); out.innerHTML += splitWork(v.v,2,true); v = v.split(parts);

          out.innerHTML += "<br />The vector ratio computed to " + parts + " reciprocal parts is the following = " + v.val.a + "<br /><br />";

          if(v.val.length < parts)
          {
            out.innerHTML += "Note that this vector zero terminated before part " + parts + " meaning it is not an ratio.<br /><br />";
            out.innerHTML += "It could be an even root such as &radic;9 = 3 or a fractional value 99&div;77, and is not an ratio.<br /><br />";
          }
          
          out.innerHTML += "We can compute reciprocal parts back into an number by adding the parts together and dividing them into one.<br /><br />";

          out.innerHTML += addParts(v,2); n = v.valueOf();

          out.innerHTML += "<br />This gives us the number " + n + "";
        }

        out.innerHTML += "<h1>Computing number to vector ratio</h1>";

        out.innerHTML += "We get the reciprocal parts of our number " + n + " by taking away the number before the decimal point and dividing into one.<br /><br />";

        out.innerHTML += getParts(n,2); n = n.splitAll();

        out.innerHTML += "<hr />Using these 2 steps we have found the reciprocal parts to our number to be " + n.a + "<hr /><br />";

        out.innerHTML +="The reciprocal parts can be added together into reciprocal fractions.<br /><br />";

        out.innerHTML += addPartsFract(n.a,3) + "<br />";

        out.innerHTML += "In math we call these converging fractions and are very important for finding irrational number ratios for numbers.<br /><br />";

        out.innerHTML += "The reciprocal fraction of the parts can be expanded to vector columns till we end with the same vector twice per added part giving us our ratio for our irrational number.<br /><br />";

        out.innerHTML += findVect(n,isVect ? bv : [1,0,0]);
      }
    </script>
  </head>
  <body>
    <div class="page" style="overflow: scroll-y;">
      <table border="1" style="width:100%;">
        <tr><td><center>Input</center></td><td><center>Max parts</center></td><td rowspan="2" style="width:100%;"><input style="width:3em;height:3em;" type="button" value="calc" onclick="getInput();" /></td></tr>
        <tr><td><input type="text" value="1,0,0,88" id="iv" onclick="this.select();" /></td><td><input type="text" value="20" id="pt" onclick="this.select();" /></td></tr>
      </table>
      <div id="out">
        <h1>Introduction</h1>

        The new vector ratio data type is an new addition to FL64.<br /><br />

        This tool helps you solve numbers that grow and never repeat, such as 0.123456, which we know will only get larger and never repeat.<br /><br />

        Some values have no visible pattern in their digits, but they grow the same way such as the number PI ratio 3.1415926535.<br /><br />

        We call these complex number patterns irrational numbers. Unravelling complex values takes a lot of work.<br /><br />

        Originally we would look for equations that match the number ratio we are looking at through a lot of calculation and proof work.<br />

        <h1>Using this tool</h1>

        Enter a custom vector combination such as 1,8,99, then hit calc to see the steps for computing each part. It then shows how the parts are added into an irrational number.<br /><br />

        The resulting irrational number is broken back into parts step by step.<br /><br />

        It then shows how the parts are added back into a vector ratio, and proves the algorithm operations and steps.<br /><br />

        All operations are simple: basic divides, multiplies, additions, and subtractions.

        <hr />

        You also can use an irrational number like 1.414213562 and hit calc instead of entering a vector combination.<br /><br />

        This tool will show you the steps to breaking the number into parts.<br /><br />

        Once the value is broken into parts, it will show how to add the parts to a vector ratio.<br /><br />

        <h1>Vector ratios</h1>

        A vector that looks like this: 1,0,77 is the square root of 77 as a vector ratio.<br /><br />

        An vector of 1,0,0,23 is the cube root of 23.<br /><br />

        A vector such as 1,0,0,0,2 is 2 to the root of 4, which is the value 1.8920711500272. Multiplying the value 1.18920711500272 four times with itself is 2.<br /><br />

        Not all irrational number ratios can be computed as the root of a number.<br /><br />

        A vector ratio of 1,8,99 is close to the square root of 99 but can not be calculated as the root of any number.<br /><br />

        The last column of a vector is to the root of a number as long as the first column is one and the rest are zero, with the last value being the value of the root.<br /><br />

        The vector computes each of the whole parts of a number ratio sequentially.
      </div>
    </div>
  </body>
</html>
