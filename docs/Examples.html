<html>
<head>
  <meta property="og:image" content="https://repository-images.githubusercontent.com/81086272/73a9ee80-65f9-11ea-9cd9-3c14b7503cff" />
  <title>FL64 Examples.</title>
</head>
<body onload="setup();">
  <style type="text/css">
    <!--
    input[type=button] {
      width: 100%;
      height: 48px;
    }

    h3 {
      display: inline-block;
    }

    @media (orientation: landscape) {
      textarea.c {
        resize: none;
        width: 70%;
        max-height: 70%;
      }

      textarea.o {
        resize: none;
        width: 30%;
        max-height: 70%;
      }
    }

    @media (orientation: portrait) {
      textarea.c {
        resize: none;
        width: 100%;
        max-height: 40%;
      }

      textarea.o {
        resize: none;
        width: 100%;
        max-height: 20%;
      }
      -->
  </style>
  <script src="../FL64.js" type="text/javascript"></script>
  <script type="text/javascript">
    var output = "";

    function setup()
    {
      var list = document.getElementsByTagName("code");

      var html = "", lines = 0, spaces = 0;

      for (var i1 = 0; i1 < list.length; i1++) {
        html = list[i1].innerHTML;

        var t = html.split("\n"); lines = t.length - 1; spaces = html.search(/\S|$/) - 1;

        for (var i2 = 0, html = ""; i2 < lines; i2++) { html += t[i2].slice(spaces, t[i2].length) + "\n"; }

        lines = list[i1].getAttribute("rows") || lines;

        list[i1].innerHTML = "<textarea class=\"c\" rows=\"" + lines + "\" id=\"e" + i1 + "\">" + html + "</textarea></textarea><textarea class=\"o\" rows=\"" + lines + "\" id=\"e" + i1 + "o\" readonly>Console output.</textarea><input type=\"button\" onclick=\"runExamp('e" + i1 + "');\" value=\"Run code.\" />";
      }
    }

    function runExamp(id)
    {
      var code = document.getElementById(id).value;

      try { eval(code); } catch (e) { console.log(e.toString()); }

      document.getElementById(id + "o").value = output; output = "";
    }

    console.log = function (msg) { output += msg + "\r\n"; }
  </script>

  <h1>Indexed contents.</h1>

  Number in Parts: <a href="#parts">Link</a><br />
  Adding parts back together: <a href="#calc">Link</a><br />
  Manipulating parts: <a href="#mparts">Link</a><br />
  Creating a number in Parts: <a href="#cparts">Link</a><br />
  Irrational numbers: <a href="#irrational">Link</a><br />
  Periodic number patterns: <a href="#dpat">Link</a><br />
  The secrete to all numbers (No such thing as random numbers): <a href="#s">Link</a><br />
  Fraction Data type: <a href="#fract">Link</a><br />
  Error Correction: <a href="#er">Link</a><br />
  Binary translation operations: <a href="#bits">Link</a><br />
  Direct Binary bitwise operations: <a href="#bwise">Link</a><br />
  Vector and Array operation: <a href="#v">Link</a>

  <h1><a id="parts">Number in Parts.</a></h1>

  1. Numbers can be split into parts.<br />
  2. Numbers have a length for numbers of parts split into.<br />

  <h3>Using the split method.</h3>

  <br />

  <code>
    var pi = 3.1415;

    pi = pi.split();

    console.log(pi);

    pi = pi.split();

    console.log(pi);
  </code>

  <br /><br />

  As you can see the more we split the value. The closer we get to 0. You can also view each part by calling the <h3>toString</h3> method.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split();

    console.log(pi.toString());

    pi = pi.split();

    console.log(pi.toString());
  </code>

  <br /><br />

  As you can see we now show all A to B parts. Followed by the remaining value.

  <br /><br />

  Each "a" is a part taken out of the number.<br />
  Each "b" is the scale used.

  <br /><br />

  Generally all b=1 is as high as it goes going to the next part in the number.

  <br /><br />

  If b is set 2, or -2. Then we are going half to the next value. Does not matter which direction -/+.

  <br /><br />

  If b is 3 then it is third in scale to the next part across the number and so on.

  <br />

  The method <h3>reValue</h3> displays the next part after each split.

  <br /><br />

  <code>
    var pi = 3.1415;

    console.log(pi.reValue());

    pi = pi.split();

    console.log(pi.reValue());

    pi = pi.split();

    console.log(pi.toString());
  </code>

  <br />

  Each <h3>reValue</h3> is what each next "a" part is at max that can be taken out of the number in the next split.

  <br />

  You can change the A, and B part to what ever you like per split. Using splits that are out of range will be accommodated for in regular <h3>split</h3> without a, or b input.

  <br /><br />

  Also the larger you set "b". The bigger "a" becomes in the next part, because of the scale size.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    console.log(pi.toString());
  </code>

  <br /><br />

  In this example we split by different values per part. We can continue to split to all parts till the value is 0.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    while( pi > 0 ) { pi = pi.split(); }

    console.log(pi.toString());
  </code>

  <br />

  Instead of using <h3>split</h3> when you want to <h3>split</h3> a number into all remaining parts. You are best off using the method <h3>splitAll</h3>. The method <h3>splitAll</h3> is much faster than <h3>split</h3> when you want to <h3>split</h3> the value till it is 0 in value.

  <br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <a id="calc"><h1>Adding parts back together.</h1></a>

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF(2, 5);

    var Number = pi.calc(2, 5);

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  Methods <h3>calcF</h3>, and <h3>calc</h3> add the parts together.

  <br /><br />

  <h3>calcF</h3> adds start to End parts to a fraction.

  <br />

  <h3>calc</h3> adds to a number from start to end parts.

  <br /><br />

  In the example above we start at part 2, and add up parts till part 5.

  <br /><br />

  If you leave both inputs blank.

  <br /><br />

  Then all parts are added to fraction by default if you do not specify where to start or end.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF();

    var Number = pi.calc();

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  You can also use the length value to stop at one part less before the end.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF(0, pi.length - 2);

    var Number = pi.calc(0, pi.length - 2);

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  Each time you split a number the length gets bigger by one. Thus the length is the number of parts a number has been split into. In the above example we subtract the length by 2. When we add the parts into a fraction or number we are adding one part less before the end.

  <br />

  <a id="mparts"><h1>Manipulating parts</h1></a>

  The parts a number is split into can also be manipulated.

  <br /><br />

  <code rows="21">
    var pi = 3.1415;

    pi = pi.splitAll();

    console.log(pi.toString());

    pi = pi.remove(4);
    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <br /><br />

  In this example part 4 is removed.

  <br /><br />

  Which is a=8, b=1.

  <br /><br />

  As you can see part 4 is gone when we display the set after the remove operation.

  <br /><br />

  Pay attention to where the end with 0 remaining value is. To see the separation between before, and after.

  <br />

  Because we changed the parts the value is no longer 0, so method <h3>splitAll</h3> is used to split to all remaining parts before displaying the after result.

  <br />

  You can see that the change was accommodated for with a=-2, b=1. Per largest part out of the number till 0 parts remain.

  <br /><br />

  <code rows="23">
    var pi = 3.1415;

    pi = pi.splitAll();

    console.log(pi.toString());

    pi = pi.setA(4, 3);
    pi = pi.setB(4, 4);

    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <br /><br />

  Instead of removing the 4th part we modify the 4th part to be a=3, b=4.

  <br />

  Methods <h3>setA</h3>, and <h3>setB</h3> Use the first value for which part then the second value for which number you wish to set it to.

  <h2>Transforming parts.</h2>

  <br />

  Lets say you want to modify a whole bunch of parts at one time.

  <br /><br />

  <code rows="40">
    var val = 1.3922111911773327;

    function A(x)
    {
      return(x);
    }

    function B(x)
    {
      return(x);
    }

    val = val.splitAll();

    console.log(val.toString());

    val = val.Trans(0,A,B);

    console.log(val.toString());
  </code>

  <br /><br />

  This is one of the most useful operations you will be using.

  <br />

  The first set of parts are the arraignment of parts that are at max value per part using method <h3>splitAll</h3>.

  <br />

  The second set is the output from the transform method. The transform method terminates if a value is out of range -/+, or if you hit 0.

  <br />

  The transform method needs two functions as inputs. Both functions take a single input. In the above example code I label it as <h3>x</h3>.

  <br />

  The input to the function adds by 1 per part. So it goes like this 1,2,3,4,5,6 and so on per part.

  <br />

  It is up to you what you want to return as a value from the two functions. In the example I return the value <h3>x</h3> which goes 1,2,3,4,5,6 and so on.

  <br />

  Each input to your fraction that is 1,2,3,4,5,6 can even be used as a array index if you wish to transform by specific values, or you can calculate each value per value.

  <br /><br />

  <h3>Some modifications you can make to see what happens is changing "val = val.Trans(0,A,B);" to "val = val.Trans(1,A,B);".</h3>

  <br /><br />

  This changes the start position in the parts you wish to transform. Also take note that the transform method will terminate sooner, because the parts will most likely be out of range -/+.

  <br /><br />

  You can change the starting position to what ever you like to see the effect for your self. Set it 3, or even 5.

  <br /><br />

  <a id="cparts"><h1>Creating A number in parts.</h1></a>

  In order to create a number you start with a value that is <h3>NaN</h3>. Which stands for <h3>Not a Number</h3>.

  <br />

  You then can do all manipulation operations, or <h3>split</h3> by "a", and "b".

  <br />

  In order to get a fraction, or number back you add the parts back together using methods <h3>calc</h3>, or <h3>calcF</h3>

  <br />

  <code>
    var val = NaN;

    val = val.split(1,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  We create the square root of 2. Using this split sequence.

  <br /><br />

  You can split into any number you like per part.

  <br /><br />

  Now lets say you wish to continue this splitting sequence to the end. Instead of doing a bunch of split operations. You are best to use the transform operation.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(2);
    }

    function B(x)
    {
      return(1);
    }

    val = val.split(1,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  In this example we split the first part as a=1, b=1.

  <br /><br />

  Then we transform the rest of the parts as a=2, b=1 using function A and B.

  <br />

  Then we add it together with the <h3>calc</h3> Method.

  <br />

  This makes the square root of 2.

  <br /><br />

  You can change this however you like. You can create any irrational number you like using this.

  <a id="irrational"><h1>Irrational Numbers.</h1></a>

  An irrational number is a value that can never be solved to it's exact value.

  <br /><br />

  An irrational number is something that looks like this: 1.01001000100001.

  <br /><br />

  Which we can clearly see what the pattern is. As it is 1 followed by one more zero per place value.

  <br /><br />

  Because of this pattern. We can make the number bigger forever without any repeating digits.

  <br /><br />

  You can split irrational numbers into smaller parts. You can also add together irrational numbers using per smaller parts.

  <br /><br />

  But the digits in the number never repeat. For example PI to a billion digits: <a href="https://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt" target="_blank">Link</a>.

  <br /><br />

  Irrational numbers are created when you measure something that gets a tiny bit bigger each time in reference to say another number.

  <br /><br />

  The most basic example is a circle. The circles outside distance gets slightly bigger than the distance across per bigger circle.

  <br /><br />

  This means you are going to get a different number each time. The farther down the decimal place per bigger circle. AS the two lengths change in ratio as you go bigger down the decimal place.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return( 6 );
    }

    function B(x)
    {
      return( 1 + (x * 4) + (x * x * 4) );
    }

    val = val.split(3,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  The above example calculates the number PI per additional part Rally quickly.

  <br /><br />

  This is much different than the physical measurement. As we add per part together to create the number.

  <br />

  <h2>The golden ratio.</h2>

  The golden ratio is a very fascinating irrational number as each part is as small as it possibly can be per part.

  <br /><br />

  All parts are exactly a=1, b=1. It is considered the most irrational number because of this.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(1);
    }

    function B(x)
    {
      return(1);
    }

    val = val.Trans(0,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <h2>Square roots.</h2>

  Every square root is related to that of the golden ratio. Here is a table of every square root.

  <br /><br />

  <table border="1">
    <tr><td colspan="2">&radic;1</td><td>_</td><td colspan="2">&radic;2</td><td>_</td><td colspan="2">&radic;3</td><td>_</td><td colspan="2">&radic;4</td><td>_</td><td colspan="2">&radic;5</td><td>_</td><td colspan="2">&radic;6</td><td>_</td><td colspan="2">&radic;7</td><td>_</td><td colspan="2">&radic;8</td><td>_</td><td colspan="2">&radic;9</td><td>_</td><td colspan="2">&radic;10</td><td>_</td><td colspan="2">&radic;11</td><td>_</td><td colspan="2">&radic;12</td><td>_</td><td colspan="2">&radic;13</td><td>_</td><td colspan="2">&radic;14</td><td>_</td><td colspan="2">&radic;15</td><td>_</td><td colspan="2">&radic;16</td><td>_</td><td colspan="2">&radic;17</td><td>_</td><td colspan="2">&radic;18</td><td>_</td><td colspan="2">&radic;19</td><td>_</td><td colspan="2">&radic;20</td><td>_</td><td colspan="2">&radic;21</td><td>_</td><td colspan="2">&radic;22</td><td>_</td><td colspan="2">&radic;23</td><td>_</td><td colspan="2">&radic;24</td></tr>
    <tr><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td></tr>
    <tr><td>1</td><td>0</td><td>_</td><td>1</td><td>1</td><td>_</td><td>1</td><td>2</td><td>_</td><td>2</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>2</td><td>3</td><td>_</td><td>2</td><td>4</td><td>_</td><td>3</td><td>0</td><td>_</td><td>3</td><td>1</td><td>_</td><td>3</td><td>2</td><td>_</td><td>3</td><td>3</td><td>_</td><td>3</td><td>4</td><td>_</td><td>3</td><td>5</td><td>_</td><td>3</td><td>6</td><td>_</td><td>4</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>4</td><td>5</td><td>_</td><td>4</td><td>6</td><td>_</td><td>4</td><td>7</td><td>_</td><td>4</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>7</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
  </table>

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(8);
    }

    function B(x)
    {
      return(7);
    }

    val = val.split(4,7);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  In this example we calculate the square root of 23.

  <br /><br />

  Also you can calculate the golden ratio as the square root of <h3>0.5+&radic;1.25=1.618033988749895</h3>.

  <br /><br />

  You have probably realized by now there are many different ways to line up per A(part) to B(scale) part. As "B" is the scale going to each "A" part.

  <br /><br />

  However there is a method in which you square the remaining part to find the best A to B per part.

  <br /><br />

  Doing this allows you to solve the patterns to all irrational numbers no matter how they are generated per part.

  <br /><br />

  This includes <h3>sine, cosine, tangent, x to y root, logarithms, and even PI</h3>.

  <br />

  Even numbers you create per digit such as 1.01001000100001. Which the irrational pattern is obvious.

  <br /><br />

  <h2>The Natural logarithm.</h2>

  <br />

  <table border="1">
    <tr><td colspan="2">Natural log.</td></tr>
    <tr><td>A</td><td>B</td></tr>
    <tr><td>2</td><td>1</td></tr>
    <tr><td>1</td><td>1</td></tr>
    <tr><td>2</td><td>2</td></tr>
    <tr><td>3</td><td>3</td></tr>
    <tr><td>4</td><td>4</td></tr>
    <tr><td>5</td><td>5</td></tr>
    <tr><td>6</td><td>6</td></tr>
    <tr><td>7</td><td>7</td></tr>
    <tr><td>8</td><td>8</td></tr>
    <tr><td>9</td><td>9</td></tr>
  </table>

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return( x );
    }

    function B(x)
    {
      return( x );
    }

    val = val.split(2,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  The natural log is another good example. As you can see this is similar to that of our square roots, and the golden ratio. With one slight difference. Each part is +1 from before.

  <br /><br />

  <a id="s"><h3>Each of these numbers relate to each other. Think of this as the golden ratio to the square, and then to natural log. In which PI is like a spiral stir case squared.</h3></a>
  
  <div style="background-color:#808080;">
    <br /><br />

    If you really do understand, and really work it out. Then you can line up any number to it's pattern.

    <br /><br />

    Then you can use the quantum matrix to convert all parts into the exact pattern <a href="https://recoskie.github.io/AI-Matrix/docs/Examples.html" target="_blank">Link</a>.

    <br /><br />
  </div>

  <h2>At the smallest scale.</h2>

  The Golden ratio is the sub structure to all other numbers. Including all irrational numbers.

  <br /><br />

  The smallest split out of a number is a=1, b=1. Which is the golden ratio.

  <br /><br />

  Adding all a, and b together per next part. Is added the same way as the Fibonacci numbers.

  <br /><br />

  By adding previous number to next number. Creates the Fibonacci sequence while multiplying by all A.

  <br />

  By adding previous number to next number. Create the Fibonacci sequence while multiplying by all B.

  <br /><br />

  Multiplying by all a=1, b=1 leaves the numbers unchanged. Creating the Fibonacci sequence per added part.

  <br /><br />

  0,1,1,2,3,5,8,13,21,34,55,89,144,233,377

  <br /><br />

  Each Fibonacci number divided by a prior Fibonacci number forums the golden ratio 377&divide;233=1.618025 per a=1, b=1. In perfect equilibrium.

  <br /><br />

  The further back you go like 55&divide;34=1.617647. Makes a less accurate value. Because you are adding fewer parts together per a=1, and b=1.

  <br /><br />

  All numbers can be split into parts then added back to their smallest fraction this way.

  <br /><br />

  By adding previous number to next number, and multiplying by each A, and B.

  <br /><br />

  So the Fibonacci sequence relates to adding per smaller part. While the golden ratio is a direct 1:1 relation to the whole.

  <br /><br />

  The golden ratio is also a perfect rectangle called the golden rectangle. Also the Fibonacci sequence, and golden ratio is also a spiral in nature.

  <br /><br />

  All numbers have a place along the spiral. Rational numbers are a finite point. While irrational numbers go forever along the spiral. There is no such thing as a random number.

  <br /><br />

  You can also calculate the golden ratio as the pentagram.

  <br /><br />

  <img style="width:600px;height:303px;" src="https://1.bp.blogspot.com/-Od04RSUVFrc/XTxqy0DtOpI/AAAAAAAAcUA/P4DsYx381x4AEAEIDQ5BoSYDT_14fDNyACLcBGAs/s1600/EAfbbb6UwAAjwby.jpeg" />

  <h2>Rational Vs Irrational.</h2>

  In theory if we could store a infinite number of digits.

  <br />

  All rational numbers can be split to 0 parts remain. Then added back to smallest fraction using <h3>calcF</h3>.

  <br />

  Irrational numbers can be split forever into smaller parts and will never hit 0.

  <br /><br />

  Computers have a limit for the number of digits we can store. So making the determination between the two is hard.

  <br /><br />

  We can say a number is irrational if the final split before 0 is at the end of the accuracy of a floating point number in the computer.

  <br /><br />

  The other method is calculating it in A to B ratio in to a pattern. Combined with the quantum matrix: <a href="https://recoskie.github.io/AI-Matrix/docs/Examples.html" target="_blank">Link</a>

  <br /><br />

  It is possible to determine one from the other even with limited digits. However it requires you to solve the squaring of B to A parts. Then using the matrix to solve the pattern.

  <a id="dpat"><h1>Periodic number patterns.</h1></a>

  Periodic number patterns happen when you divide a number that does not divide evenly out of the number of digits you are using per place value.

  <br /><br />

  Many people use to think that the number PI would eventually repeat. When a number repeats, this means it can be represented as a "finite value = single fraction".

  <br /><br />

  The next place value is 10, so we subtract one making it 10-1=9. When we divide any number by 9 it will create a remainder that is the same going in and out across the number forever.

  <br /><br />

  <table border="1">
    <tr><td>1&divide;9</td><td>0.111111111111111</td></tr>
    <tr><td>2&divide;9</td><td>0.222222222222222</td></tr>
    <tr><td>3&divide;9</td><td>0.333333333333333</td></tr>
    <tr><td>4&divide;9</td><td>0.444444444444444</td></tr>
    <tr><td>5&divide;9</td><td>0.555555555555555</td></tr>
    <tr><td>6&divide;9</td><td>0.666666666666666</td></tr>
    <tr><td>7&divide;9</td><td>0.777777777777777</td></tr>
    <tr><td>8&divide;9</td><td>0.888888888888888</td></tr>
  </table>

  <br />

  You can make the fractions smaller. You can change 3&divide;9 to 1&divide;3. Which is the same fraction.

  <br /><br />

  What is happening is that we have ten possible digits per place value. We have 0,1,2,3,4,5,6,7,8,9.

  <br /><br />

  Thus anything divided by the last digit creates a indivisible remainder that is the same across the number forever.

  <br /><br />

  The next place value is 10*10=100, so 100-1=99. Any two digits divided by 99 will repeat forever across the number as it is indivisible.

  <br /><br />

  23&divide;99=0.23232323232323

  <br /><br />

  The next place value is 100*10=1000, so 1000-1 is 999. Thus any three digits divided by 999 will be indivisible.

  <br /><br />

  719&divide;999=0.719719719719719

  <br /><br />

  You can make any number you like that is indivisible. Thus creates a number pattern using division. That is recurring, and periodic.

  <br /><br />

  <code>
    var val = 3 / 9;

    console.log(val);
  </code>

  <br /><br />

  In this example you can try it out your self. You can also change the 3&divide;9 (3 / 9) with every value you come up with that is indivisible.

  <br /><br />

  However periodic number patterns relate to the number of digits you are using to display your value in per divisible place value.

  <br /><br />

  <code>
    var val = 3 / 9;

    console.log(val.toString(3));
  </code>

  <br /><br />

  In this example the fraction 3&divide;9 works out as 0.1. This is because we are dividing the number up in place values of 3. Which is what <h3>toString(3)</h3> does.

  <br /><br />

  This is called changing the number base from base 10 to base 3. Instead of each place value being in 10 per place value. It is in place values of 3.

  <br /><br />

  This means we have three digits instead of ten. Thus in three digits 1&divide;3 is perfectly dividable as one third = 0.1.

  <br /><br />

  Changing the number of digits we use in a number system changes what is divisible between the number of digits.

  <br /><br />

  However even base three has the following indivisible values.

  <br /><br />

  As the first place value is 3. So 3-1=2.

  <br />

  And the second place value is 3*3=6. So 6-1=5.

  <br /><br />

  <table border="1">
    <tr><td>1&divide;2</td><td>0.111111111111111</td></tr>
    <tr><td>1&divide;5</td><td>0.012101210121012</td></tr>
    <tr><td>2&divide;5</td><td>0.101210121012101</td></tr>
    <tr><td>3&divide;5</td><td>0.121012101210121</td></tr>
    <tr><td>4&divide;5</td><td>0.210121012101210</td></tr>
  </table>

  <br />

  For example half of something can never be dividable out of thirds per place value. However half of ten digits is evenly 5, so a half out of ten units is 0.5.

  <br />

  So it does not matter what the number of digits you use are. You get the same problem. You end up with 50% divisible numbers, and 50% indivisible periodic numbers. Even if you used base 60 numbers.

  <br />

  Don't worry so much about divisibility of place values in a number system though. Since you can split these types of numbers into parts. Then add the parts together into smallest fraction with <h3>calcF</h3>.

  <br />

  <code>
    var val = 3 / 9;

    val = val.splitAll();
    val = val.calcF();

    console.log(val.toString());
  </code>

  <br /><br />

  This way you do not have to worry about these messed up types of numbers.

  <br /><br />

  So Division has some useful characteristics.

  <br /><br />

  1. Such as algorithms that find, and translate recurring (periodic) patterns quickly in data with a single calculation.

  <br />

  2. Generating fun random looking sequences that repeat infinitely periodically.

  <br />

  <h2>Creating a division pattern.</h2>

  To create a new division pattern you use the <h3>Pattern</h3> data type.

  <br />

  <code>
    var pat = new Pattern("31415",10);

    console.log(pat);

    var fract = pat.getFract();

    console.log(fract.toString());
  </code>

  <br /><br />

  We chose the pattern 31415, using out of ten digits. Thus we use the method <h3>getFract</h3> to get the smallest fraction.

  <br /><br />

  We can get more complex than this if we like.

  <br /><br />

  <code>
    var pat = new Pattern("DAMIAN",24);

    console.log(pat);

    var fract = pat.getFract();

    var val = fract.valueOf();

    console.log(fract.toString());

    console.log(val.toString(24));
  </code>

  <br /><br />

  In this example I encode my name into a division pattern. AS you can see the pattern is displayed first. Then fraction. Then value in base 24.

  <br /><br />

  You can encode things like this if you like. When I display the value my name is 0.DAMIAN<div style="display:inline-block;color:#FF0000;">DAMIB</div>.

  <br /><br />

  It gets cut off at DAMIB the second time. The last digit that should be an A gets rounded up to B, because it is the last digit of accuracy in the floating point value.

  <br /><br />

  IF you do not specify the number base. The pattern data type will default to binary. Since numbers are binary in the computer by default.

  <br /><br />

  <code>
    var pat = new Pattern("1011");

    console.log(pat);

    var fract = pat.getFract();

    var val = fract.valueOf();

    console.log(fract.toString());

    console.log(val.toString(2));
  </code>

  <br /><br />

  It is fun working with numbers in different divisible parts.

  <br /><br />

  However you have to remind yourself that it is all in binary place values. Even though we can round stuff off, and divide by different place values.

  <br /><br />

  <h2>Finding the division pattern.</h2>

  <br />

  Lets say you wish to find what the periodic pattern of a fraction, or number is.

  <br /><br />

  <code>
    var f = new Fract(711,911);

    var val = f.valueOf();

    console.log(val.toString(2));

    console.log(f.toString());

    var pat = f.divP();

    console.log(pat.toString());
  </code>

  <br /><br />

  You start by creating a fraction. You then call the operation <h3>divP</h3>. Which divides the value in binary. It finds the two points that equal the same remainder. Then creates the pattern.

  <br /><br />

  In the example code. The first output is the value of the fraction in binary. The second output is the fraction. Then last output is the division pattern before any recurrence.

  <br /><br />

  Assuming you wish to find the division pattern of a value. You then get the fraction of the value then call <h3>divP</h3>.

  <br /><br />

  <code>
    var val = 711 / 911;

    console.log(val.toString(2));

    var f = val.getFract();

    var pat = f.divP();

    console.log(pat.toString());
  </code>

  <br /><br />

  Now all of this is done in binary by default. You can actually pass the number base you want to <h3>divP</h3>.

  <br />

  This will then force division pattern in other number bases like base 10.

  <br /><br />

  <code>
    var f = new Fract(711,911);

    var val = f.valueOf();

    console.log(val.toString());

    console.log(f.toString());

    var pat = f.divP(10);

    console.log(pat.toString());
  </code>

  <br /><br />

  And lets say you wish to convert to a base 10 pattern from just the number value.

  <br /><br />

  <code>
    var val = 711 / 911;

    console.log(val.toString());

    var f = val.getFract();

    var pat = f.divP(10);

    console.log(pat.toString());
  </code>

  <br />

  <a id="fract"><h1>Fraction data type.</h1></a>

  Fractions are useful for values that are periodic. See the section on Periodic number patterns: <a href="#dpat">Link</a>.

  <br /><br />

  Such values should be avoided if possible by storing the fraction instead, or splitting such numbers into parts. Then adding the parts back to a fraction.

  <br /><br />

  However the fraction data type is not useful for numbers that are a infinite pattern of parts. This is because such values can never be a finite value. See the section Irrational numbers:  <a href="#irrational">Link</a>.

  <br /><br />

  In binary. Lots of decimal values become un-dividable in place values of two. See the following documentation: <a href="https://docs.python.org/2/tutorial/floatingpoint.html" target="_blank">Link</a>.

  <br /><br />

  Such values can be converted into two floating point values that divide to the value without error. Which is what the fraction data type does.

  <br /><br />

  The reason it works is that we can store numbers as whole numbers in binary without error. Then add them. Then divide to the exact number.

  <br /><br />

  <code>
    var f1 = new Fract(1,10);
    var f2 = new Fract(2,10);

    //Add the two fractions.

    f1.x += f2.x;

    //Display the result.

    console.log(f1);
  </code>

  <br /><br />

  Now normally adding 0.1 with 0.2 would create a floating point error. However it does not this time. Because we are using whole number values that can be represented in binary perfectly.

  <br /><br />

  You can multiply, add, and subtract. Such values without any errors as the fraction data type.

  <br /><br />

  Each fraction has a <h3>x</h3>, and <h3>y</h3>.

  <br />

  <h3>x</h3> is the numerator floating point value.

  <br />

  <h3>y</h3> is the denominator floating point number.

  <br /><br />

  This form of arithmetic is preferred in applications that require extremely high accuracy with very little impact on performance.

  <br /><br />

  Now adding 0.1, and 0.2 regularly as follows will result in error.

  <br /><br />

  <code>
    var f1 = 0.1;
    var f2 = 0.2;

    //Add the two numbers.

    f1 += f2;

    //Display the result.

    console.log(f1);
  </code>

  <br /><br />

  The <h3>reduce</h3> method splits the fraction into parts then adds the parts back into the smallest fraction.

  <br /><br />

  <code>
    var f = new Fract(31415,10000);

    //Display fraction.

    console.log(f.toString());

    //Smallest fraction.

    f = f.reduce();

    //Display the result.

    console.log(f.toString());
  </code>

  <br /><br />

  The Fraction data type lets you use the <h3>divP</h3> method to find what the indivisible pattern is.

  <br /><br />

  <code>
    var f = new Fract(2,10);

    //Indivisible part in binary base 2.

    var pat = f.divP(2);

    //Display the indivisible pattern.

    console.log(pat);
  </code>

  <br />

  So 0.2 ends up having the recurring pattern <h3>0011&infin;</h3> forever. You can change the <h3>divP(2)</h3> to other number bases if you wish to find if the fraction is dividable in other number bases other than binary.

  <br />

  For example if you change base 2 to base 10 with <h3>divP(10)</h3>. Then you will get the output <h3>0&infin;</h3>. This means there is no reminder. Which means it divides in base 10, but not as a base 2 binary number.

  <br />

  You can only use <h3>divP</h3> with the fraction data type.

  <br />

  The method <h3>getFract</h3> gives back a fraction from numbers, and patterns. By splitting to all parts then adding all parts back to a fraction.

  <br />

  It is methods <h3>splitAll</h3>, and <h3>calcF</h3> combined.

  <br />

  Also Method <h3>calcF</h3> gives back the fraction data type. Which also would allow you to use <h3>divP</h3> with added up parts.

  <br />

  It is important for you to know this so you do not use a method like <h3>divP</h3>, or even <h3>reduce</h3>. Unless you convert to a fraction data type first.

  <a id="er"><h1>Error Correction.</h1></a>

  Generally error correction is not rally necessary. If you write your code, and algorithms using the fraction data type: <a href="#fract">Link</a>.

  <br /><br />

  In that section. I explain floating point error, and how to overcome it. With as little performance loss as possible.

  <br /><br />

  Errors happen at the last place value in a number. When you add values together that do not divide evenly into a binary number.

  <br /><br />

  When a number is split into parts. The last part is usually where the error is accumulated.

  <br /><br />

  However removing the last part. Is not possible. If there is no error. As it will create a less accurate number when added back together. Resulting in error.

  <br /><br />

  What we can do. Is that the part ends up being rally big in size compared to the other A, B parts. So we average the parts. Then remove the parts at the end of the number that are bigger than average.

  <br /><br />

  So here is an example where we introduce error into a floating point value. Then error correct it.

  <br /><br />

  <code>
    var n = 3.147547;

    var er = 1; //Number Of binary digits.

    //The exponent position using log 2.

    var pos = Math.round(Math.log(n)/Math.log(2));

    //The last binary digit.

    var er = 2**(pos-(53-er)); er -= 2**(pos-53);

    //Show the error that is being introduced.

    console.log( "Value before error is introduced.\r\n\r\n" + n.toString(2) + "\r\n\r\n" );

    console.log( "Value that is going to be added to Number as error.\r\n\r\n" + er.toString(2) + "\r\n\r\n" );

    n += er;

    console.log( "Value After error is introduced.\r\n\r\n" + n.toString(2) + "\r\n\r\n" );

    //Show various stats about the number in question.

    n.stats();

    //Call the error correction method on the number.

    console.log( "\r\n\r\nError corrected value = " + n.err() );
  </code>

  In this example I use the method <h3>stats</h3>. It displays everything about any number you use it with.

  <br /><br />

  As you can see there is a big jump at the last part.

  <br /><br />

  Generally we only need to remove the part at the end of the number. Going backwards that is higher than average.

  <br /><br />

  When the method <h3>err</h3> is used on a number. It gives back the number value error corrected.

  <br /><br />

  There is a lot you can change in this example code if you like. You can change the number used which is variable "n". You can make the error bigger by change the "er = 1" to say "er = 5".

  <br /><br />

  <h1>To Average fraction.</h1>

  <br />

  There are also other forums of error correction such as translating to a average fraction.

  <br /><br />

  Rather than calling <h3>getFract</h3> on numbers, or using <h3>getFract</h3> on the pattern data type. Instead you can use <h3>avgFract</h3>.

  <br /><br />

  <code>
    var n = 3.147547;

    var er = 1; //Number Of binary digits.

    //The exponent position using log 2.

    var pos = Math.round(Math.log(n)/Math.log(2));

    //The last binary digit.

    var er = 2**(pos-(53-er)); er -= 2**(pos-53);

    //Show the error that is being introduced.

    console.log( "Value before error is introduced.\r\n\r\n" + n.toString(2) + "\r\n\r\n" );

    console.log( "Value that is going to be added to Number as error.\r\n\r\n" + er.toString(2) + "\r\n\r\n" );

    n += er;

    console.log( "Value After error is introduced.\r\n\r\n" + n.toString(2) + "\r\n\r\n" );

    //Show various stats about the number in question.

    n.stats();

    //Call the error correction method on the number.

    console.log( "\r\n\r\nError corrected value = " + n.avgFract().toString() );
  </code>

  <br /><br />

  This time when error correcting the value. We convert to a fraction that is the average of all "a" parts.

  <br /><br />

  This is very useful if you wish to receive number inputs from a septate method, or routine. That you know may have error.

  <br /><br />

  You then can translate to a fraction. Then you can do arithmetic with fraction data types. To have less error overall.

  <br /><br />

  <h1>Setting a limit.</h1>

  <br />

  The last forum of error correction is setting a cut off range. Normally the cut off range is the last digit in a floating point number.

  <br /><br />

  The last floating point digit is 53 away in place values of 2. So 2^52=4503599627370496 as a number. Which has a move-able exponent.

  <br /><br />

  We then divide this large number into one to get a value at which the number is cut off at.

  <br /><br />

  In which 1&divide;4503599627370496=2.22044604925031-16 is the default cut off range when spiting a number into parts.

  <br /><br />

  The methods <h3>split</h3>, <h3>splitAll</h3> use this value to find when all parts are split out of the number.

  <br />

  The methods <h3>getFract</h3>, <h3>avgFract</h3> use this value as well to convert to fraction. As they split to the last part of the number.

  <br />

  The method <h3>Trans</h3>, Stops transforming all parts at the cut off range.

  <br />

  <code>
    var pi = Math.PI;

    pi = pi.splitAll();

    console.log(pi.toString());

    //Set the limit.

    pi.limit( 1 / Math.pow(2, 26 ) );

    console.log(pi.toString());
  </code>

  <br /><br />

  AS you can see. The first time we split to all parts. We split right to the end. After we set the limit to half of 52, which is 26. We then have over 50% of the number gone.

  <br /><br />

  The value is set 0 at cut off range. In this next example the limit is set back to normal.

  <br /><br />

  <code>
    var pi = Math.PI;

    pi = pi.splitAll();

    console.log(pi.toString());

    //Set the limit.

    pi.limit( 1 / Math.pow(2, 26 ) );

    console.log(pi.toString());

    //Set limit back to normal.

    pi.limit( 1 / Math.pow(2, 52 ) );

    //Split to all parts again.

    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <br /><br />

  You can change the limit how ever you like without losing the value of the number. It just sets the 0 point.

  <br /><br />

  Also if you do not like the limit as a positional number in place values. You can convert to out of 52 place values into a percentage of 0% to 100%.

  <br /><br />

  <code>
    var ac = 50;

    var pi = Math.PI.limit( 1 / ( Math.pow( 2, 52 / ( 100 / ac ) ) ) );

    var fract = pi.getFract();

    console.log(fract.toString());
  </code>

  <br /><br />

  You can go by percent, or number of places.

  <br /><br />

  Setting the cut off point is good, for error correcting a value. If you know the number of adds, multiply, basically arithmetic operations that occurred.

  <br /><br />

  You then can add up the max possible error into number of place values. This is called dynamic error correction.

  <br /><br />

  <a id="bits"><h1>Binary translation operations.</h1></a>

  You can convert the number into pure binary using the <h3>bits</h3> operation. Once the number is in binary. You can manipulate the exponent, mantissa, and even the sing bit.

  <code>
    var val = 27.34;

    val = val.bits();

    console.log(val.toString());

    val.sing = 1;
    val.exp += 1;
    val.mantissa += 1;

    console.log(val.toString());
  </code>

  In this example we convert the number to it's 64 bit binary value using <h3>toString</h3>. We set the sing bit one at the start of the number that can be a 0, or 1. We move the exponent one place value. Which the exponent is the next 11 binary digits after the sing. Then we add our 52 binary digits of our number by one.

  <br /><br />

  As you can see the binary value from before then after. You can make any floating point number manipulation you like using this.

  <br /><br />

  If <h3>toString</h3> is not used the floating point value is used.

  <br /><br />

  <code>
    var val = 27.34;

    val = val.bits();

    console.log(val);

    val.sing = 1;
    val.exp += 1;
    val.mantissa += 1;

    console.log(val);
  </code>

  <br /><br />

  However doing any math operation with the binary number will convert the number back to a regular number.

  <br /><br />

  <code>
    var val = 27.34;

    val = val.bits();

    val = val + 0;

    console.log(val);

    val.sing = 1;
    val.exp += 1;
    val.mantissa += 1;

    console.log(val);
  </code>

  <br /><br />

  It will convert back to a number. So if you want to do binary operations on it's sing, exponent, mantissa. You have to convert it back to binary with the <h3>bits</h3> method.

  <br /><br />

  You can also change the 64 bit binary representation into any number base from 2 to 36 per place value.

  <br /><br />

  <code>
    var val = 27.34;

    val = val.bits();

    console.log(val.toString(10));
  </code>

  <br /><br />

  You can also convert any 64 bit binary representation of a number back into a number with the new <h3>parseNumber</h3> method.

  <br /><br />

  <code>
    var val = parseNumber("04628388743545398231", 10);

    console.log(val);
  </code>

  <br /><br />

  Normally this method translates 64 binary digits to a floating point number if you leave out the ", 10".

  <br /><br />

  <code>
    var val = parseNumber("0100000000111011010101110000101000111101011100001010001111010111");

    console.log(val);
  </code>

  <br /><br />

  This time just the 64 bit binary value is used by default. If no number base is specified.

  <br /><br />

  Also the <h3>parseFloat</h3> operation has been updated to Handel changing floating point numbers in different bases back to a number value.

  <br /><br />

  For example the number PI in base 36.

  <br /><br />

  <code>
    var val = Math.PI;

    console.log(val.toString(36));
  </code>

  <br /><br />

  Now with the updated <h3>parseFloat</h3>. We can convert the value back to it's exact number by specifying base 36.

  <br /><br />

  <code>
    var val = parseFloat("3.53I5AB8P5F", 36);

    console.log(val);
  </code>

  <br /><br />

  Working with number bases like this with perfect accuracy was not possible before. If you remove ", 36". Then the default is base 10.

  <br /><br />

  <code>
    var val = parseFloat("3.141592653589793");

    console.log(val);
  </code>

  <br /><br />

  The round off point is calculated in multiples relative to the rounding off point in binary. This ensures there is no loss when changing numbers between different number bases.

  <br /><br />

  However you can view what the real value looks like in full. Because 0.1 is indivisible as a binary number. So it is rounded off at 0.1 in decimal relative to the last multiple of 10 that is accurate in binary place values.

  <br /><br />

  <code>
    var val = 0.1;

    console.log( val.toString( 10, true ) );
  </code>

  <br /><br />

  This gives us the decimal value 0.10000000000000000555111512312578270211815834045410156. Which is rounded off to 0.1. Almost all decimal values do not divide evenly as a binary number.

  <br /><br />

  See the following documentation on why: <a href="https://docs.python.org/2/tutorial/floatingpoint.html" target="_blank">Link</a>.

  <br /><br />

  Using ", true" forces the true representation of a floating point value, without any rounding off in any number base, from 2 to 36.

  <br /><br />

  <code>
    var val = Math.PI;

    console.log( val.toString( 10, true ) );
  </code>

  <br /><br />

  The best representation of PI without any rounding off as a 64 bit floating point number is exactly 3.141592653589793115997963468544185161590576171875.

  <br /><br />

  It is rounded off at 3.141592653589793. As that is the only places that are truly accurate to number of binary digits in a floating point number.

  <br /><br />

  <code>
    var val = Math.PI;

    console.log( val.toString( 36, true ) );
  </code>

  <br /><br />

  The real representation of PI in base 36. Without any rounding off as a 64 bit floating point number is exactly 3.53I5AB8P5FC5VAYQTER60F6R.

  <a id="bwise"><h1>Bitwise Operations.</h1></a>

  <br />

  You can now do logical operations on all 64 binary digits of a floating point number.

  <br /><br />

  Doing any bitwise operation on a floating point number changes the number into a binary number. See the section on binary translation: <a href="#bits">Link</a>.

  <br /><br />

  Before javascript would convert to a 32 bit number during logical operations. Then back to a floating point number.

  <br /><br />

  Lets start with one of the basics such as a left shift.

  <br /><br />

  <code>
    var n = Math.PI;

    for( var i = 0; i < 64; i++ )
    {
      n = n.bitLsh(1);

      console.log(n.toString());
    }
  </code>

  <br /><br />

  In this example we left shift the number 64 times by 1. What this does it move all the binary digits to the left by one.

  <br /><br />

  The number gets converted to a binary number as soon as you do any logical bitwise operation on the floating point number.

  <br />

  You can also display the decoded float value if you remove the <h3>toString</h3> method. Which is the regular behavour for a binary number.

  <br /><br />

  <code>
    var n = Math.PI;

    for( var i = 0; i < 64; i++ )
    {
      n = n.bitLsh(1);

      console.log(n);
    }
  </code>

  <br /><br />

  This differs greatly as it rally does let you do 64 bit bitwise arithmetic operations as a floating point value.

  <br /><br />

  <code>
    var n = Math.PI;

    for( var i = 0; i < 64; i++ )
    {
      n = n.bitRsh(1);

      console.log(n.toString());
      console.log(n);
    }
  </code>

  <br />

  Also <h3>bitRsh</h3> is right shift. It is the same as left shift. Except it moves the binary digits to the right. Number of places. Instead of to the left.

  <br />

  You can change the number of places from 1 at a time to 2 at a time to the right or more if you like.

  <br /><br />

  You can also do operations like the logical "NOT" operation which converts all ones to zeros, and all zeros to ones. It inverts the binary number.

  <br /><br />

  <code>
    var n = Math.PI;

    n = n.bits();

    console.log(n);
    console.log(n.toString());

    n = n.bitNot();

    console.log(n);
    console.log(n.toString());
  </code>

  <br /><br />

  This time I convert the number to it's binary using the bit's operation, so I can show the binary value before the bits based operation "NOT".

  <br />

  As you can see the two numbers are opposite to each other. Inverting a floating point number is very inserting. For example you can change <h3>var n = Math.PI;</h3> to <h3>var n = 7;</h3>. Change the value to what ever you like.

  <br />

  Then we have operations like "XOR", "AND", "OR".

  <br /><br />

  <code>
    var n = Math.PI;

    n = n.bits();

    console.log(n);
    console.log(n.toString());

    n = n.bitAnd(2.1);

    console.log(n);
    console.log(n.toString());
  </code>

  <br /><br />

  In this example we do a logical "AND" against the number PI with the 64 bit floating point value "2.1".

  <br /><br />

  The value 2.1 in binary is 0100000000000000110011001100110011001100110011001100110011001101

  <br /><br />

  The number PI is 0100000000001001001000011111101101010100010001000010110100011000

  <br /><br />

  The logical "AND" operations only outputs a one if the two binary digits are a 1 in the same place values. This creates a very interesting operation when it comes to floating point numbers.

  <br /><br />

  <code>
    var n = Math.PI;

    n = n.bits();

    console.log(n);
    console.log(n.toString());

    n = n.bitOr(2.1);

    console.log(n);
    console.log(n.toString());
  </code>

  <br /><br />

  This time we do a logical "OR" with the same values we did with the logical "AND" operation.

  <br /><br />

  The logic operation "OR" outputs a 1 if aether place values from both numbers are a 1. So it sets the place value a one if it is a one in aether number merging the place values. Except place values that are both 0 in both numbers.

  <br /><br />

  This also has some interesting effects on floating point numbers when comparing them just as logical "AND" does.

  <br /><br />

  <code>
    var n = Math.PI;

    n = n.bits();

    console.log(n);
    console.log(n.toString());

    n = n.bitXor(2.1);

    console.log(n);
    console.log(n.toString());
  </code>

  <br /><br />

  The logical XOR operation only outputs a 1 if both place values are different. If both place are the same output is 0.

  <br /><br />

  Doing a XOR with the same number will result in 0 all across the number since the binary digits are the same. Thus you only get a one output if digits do not match.

  <br />

  Also you do not have to use just <h3>2.1</h3> as the value you do a "XOR", "AND", "OR", operation with. You can also change <h3>Math.PI</h3> to any number you like.

  <a id="v"><h1>Vector and array operations.</h1></a>

  We can also do all the floating point operations on a group of numbers rather than one number at a time.

  <br /><br />

  <code>
    var array = [7, 7.7, 9.11, 3.11, 723];

    array = array.bits();

    console.log(array.join("\r\n"));
  </code>

  <br /><br />

  As you can see all numbers in the array are converted to binary numbers with the <h3>bits</h3> operation.

  <br />

  Thus <h3>join</h3> is an array operation. It converts all numbers in the array <h3>toString</h3> using the <h3>toString</h3> operation on all numbers in the array.

  <br /><br />

  The input "\r\n" is what we wish to use as a separator between each thing in the array. Thus "\r\n" is the code for a new line.

  <br /><br />

  <code>
    var array = [7, 7.7, 9.11, 3.11, 723];

    array = array.getFract();

    console.log(array.join("\r\n"));
  </code>

  <br /><br />

  Call the method <h3>getFract</h3> on all numbers in the array. Basically all operations. You would use on a single number. Is usable with array.

  <br /><br />

  This makes a big shortcut, for writing algorithms, and code to also error correct all numbers with a single <h3>err</h3> on an array.

  <br /><br />

  <code>
    var array = [7, 7.7, 9.11, 3.11, 723];

    array = array.bitRsh(1);

    console.log(array.join("\r\n"));
  </code>

  <br /><br />

  Right shift all numbers by one. All number operations can be used with a group of numbers in an array.
</body>
</html>