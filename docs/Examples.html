<html>
<head>
  <meta property="og:image" content="https://repository-images.githubusercontent.com/81086272/73a9ee80-65f9-11ea-9cd9-3c14b7503cff" />
  <title>FL64 Examples.</title>
</head>
<body onload="setup();">
  <style type="text/css">
    <!--
    input[type=button] {
      width: 100%;
      height: 48px;
    }

    h3 {
      display: inline-block;
    }

    @media (orientation: landscape) {
      textarea.c {
        resize: none;
        width: 70%;
        max-height: 70%;
      }

      textarea.o {
        resize: none;
        width: 30%;
        max-height: 70%;
      }
    }

    @media (orientation: portrait) {
      textarea.c {
        resize: none;
        width: 100%;
        max-height: 40%;
      }

      textarea.o {
        resize: none;
        width: 100%;
        max-height: 20%;
      }
      -->
  </style>
  <script src="../FL64.js" type="text/javascript"></script>
  <script type="text/javascript">
    var output = "";

    function setup()
    {
      var list = document.getElementsByTagName("code");

      var html = "", lines = 0, spaces = 0;

      for (var i1 = 0; i1 < list.length; i1++) {
        html = list[i1].innerHTML;

        var t = html.split("\n"); lines = t.length - 1; spaces = html.search(/\S|$/) - 1;

        for (var i2 = 0, html = ""; i2 < lines; i2++) { html += t[i2].slice(spaces, t[i2].length) + "\n"; }

        lines = list[i1].getAttribute("rows") || lines;

        list[i1].innerHTML = "<textarea class=\"c\" rows=\"" + lines + "\" id=\"e" + i1 + "\">" + html + "</textarea></textarea><textarea class=\"o\" rows=\"" + lines + "\" id=\"e" + i1 + "o\" readonly>Console output.</textarea><input type=\"button\" onclick=\"runExamp('e" + i1 + "');\" value=\"Run code.\" />";
      }
    }

    function runExamp(id)
    {
      var code = document.getElementById(id).value;

      try { eval(code); } catch (e) { console.log(e.toString()); }

      document.getElementById(id + "o").value = output; output = "";
    }

    console.log = function (msg) { output += msg + "\r\n"; }
  </script>

  <h1>Indexed contents.</h1>

  Number in Parts: <a href="#parts">Link</a><br />
  Adding parts back together: <a href="#calc">Link</a><br />
  Manipulating parts: <a href="#mparts">Link</a><br />
  Creating a number in Parts: <a href="#cparts">Link</a><br />
  Irrational numbers:  <a href="#irrational">Link</a><br />
  Periodic patterns:  <a href="#dpate">Link</a><br />
  Fraction Data type: <a href="#fract">Link</a><br />
  Error Correction:  <a href="">Link</a><br />
  Binary operations: <a href="">Link</a><br />
  Vector and Array operation:  <a href="">Link</a>

  <h1><a id="parts">Parts.</a></h1>

  1. Numbers can be split into parts.<br />
  2. Numbers have a length for numbers of parts split into.<br />

  <h3>Using the split method.</h3>

  <br />

  <code>
    var pi = 3.1415;

    pi = pi.split();

    console.log(pi);

    pi = pi.split();

    console.log(pi);
  </code>

  <br /><br />

  As you can see the more we split the value. The closer we get to 0. You can also view each part by calling the <h3>toString</h3> method.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split();

    console.log(pi.toString());

    pi = pi.split();

    console.log(pi.toString());
  </code>

  <br /><br />

  As you can see we now show all A to B parts. Followed by the remaining value.

  <br /><br />

  Each "a" is a part taken out of the number.<br />
  Each "b" is the scale used.

  <br /><br />

  Generally all b=1 is as high as it goes going to the next part in the number.

  <br /><br />

  If b is set 2, or -2. Then we are going half to the next value. Does not matter which direction -/+.

  <br /><br />

  If b is 3 then it is third in scale to the next part across the number and so on.

  <br />

  The method <h3>reValue</h3> displays the next part after each split.

  <br /><br />

  <code>
    var pi = 3.1415;

    console.log(pi.reValue());

    pi = pi.split();

    console.log(pi.reValue());

    pi = pi.split();

    console.log(pi.toString());
  </code>

  <br />

  Each <h3>reValue</h3> is what each next "a" part is at max that can be taken out of the number in the next split.

  <br />

  You can change the A, and B part to what ever you like per split. Using splits that are out of range will be accommodated for in regular <h3>split</h3> without a, or b input.

  <br /><br />

  Also the larger you set "b". The bigger "a" becomes in the next part, because of the scale size.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    console.log(pi.toString());
  </code>

  <br /><br />

  In this example we split by different values per part. We can continue to split to all parts till the value is 0.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    while( pi > 0 ) { pi = pi.split(); }

    console.log(pi.toString());
  </code>

  <br />

  Instead of using <h3>split</h3> when you want to <h3>split</h3> a number into all remaining parts. You are best off using the method <h3>splitAll</h3>. The method <h3>splitAll</h3> is much faster than <h3>split</h3> when you want to <h3>split</h3> the value till it is 0 in value.

  <br />

  <code>
    var pi = 3.1415;

    pi = pi.split(7,9);

    pi = pi.split(3,5);

    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <a id="calc"><h1>Adding parts back together.</h1></a>

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF(2, 5);

    var Number = pi.calc(2, 5);

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  Methods <h3>calcF</h3>, and <h3>calc</h3> add the parts together.

  <br /><br />

  <h3>calcF</h3> adds start to End parts to a fraction.

  <br />

  <h3>calc</h3> adds to a number from start to end parts.

  <br /><br />

  In the example above we start at part 2, and add up parts till part 5.

  <br /><br />

  If you leave both inputs blank.

  <br /><br />

  Then all parts are added to fraction by default if you do not specify where to start or end.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF();

    var Number = pi.calc();

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  You can also use the length value to stop at one part less before the end.

  <br /><br />

  <code>
    var pi = 3.1415;

    pi = pi.splitAll();

    var fract = pi.calcF(0, pi.length - 2);

    var Number = pi.calc(0, pi.length - 2);

    console.log(pi.toString());

    console.log(fract.toString());

    console.log(Number.toString());
  </code>

  <br /><br />

  Each time you split a number the length gets bigger by one. Thus the length is the number of parts a number has been split into. In the above example we subtract the length by 2. When we add the parts into a fraction or number we are adding one part less before the end.

  <br />

  <a id="mparts"><h1>Manipulating parts</h1></a>

  The parts a number is split into can also be manipulated.

  <br /><br />

  <code rows="21">
    var pi = 3.1415;

    pi = pi.splitAll();

    console.log(pi.toString());

    pi = pi.remove(4);
    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <br /><br />

  In this example part 4 is removed.

  <br /><br />

  Which is a=8, b=1.

  <br /><br />

  As you can see part 4 is gone when we display the set after the remove operation.

  <br /><br />

  Pay attention to where the end with 0 remaining value is. To see the separation between before, and after.

  <br />

  Because we changed the parts the value is no longer 0, so method <h3>splitAll</h3> is used to split to all remaining parts before displaying the after result.

  <br />

  You can see that the change was accommodated for with a=-2, b=1. Per largest part out of the number till 0 parts remain.

  <br /><br />

  <code rows="23">
    var pi = 3.1415;

    pi = pi.splitAll();

    console.log(pi.toString());

    pi = pi.setA(4, 3);
    pi = pi.setB(4, 4);

    pi = pi.splitAll();

    console.log(pi.toString());
  </code>

  <br /><br />

  Instead of removing the 4th part we modify the 4th part to be a=3, b=4.

  <br />

  Methods <h3>setA</h3>, and <h3>setB</h3> Use the first value for which part then the second value for which number you wish to set it to.

  <br />

  <h2>Transforming parts.</h2>

  Lets say you want to modify a whole bunch of parts at one time.

  <br /><br />

  <code rows="40">
    var val = 1.3922111911773327;

    function A(x)
    {
      return(x);
    }

    function B(x)
    {
      return(x);
    }

    val = val.splitAll();

    console.log(val.toString());

    val = val.Trans(0,A,B);

    console.log(val.toString());
  </code>

  <br /><br />

  This is one of the most useful operations you will be using.

  <br />

  The first set of parts are the arraignment of parts that are at max value per part using method <h3>splitAll</h3>.

  <br />

  The second set is the output from the transform method. The transform method terminates if a value is out of range -/+, or if you hit 0.

  <br />

  The transform method needs two functions as inputs. Both functions take a single input. In the above example code I label it as <h3>x</h3>.

  <br />

  The input to the function adds by 1 per part. So it goes like this 1,2,3,4,5,6 and so on per part.

  <br />

  It is up to you what you want to return as a value from the two functions. In the example I return the value <h3>x</h3> which goes 1,2,3,4,5,6 and so on.

  <br />

  Each input to your fraction that is 1,2,3,4,5,6 can even be used as a array index if you wish to transform by specific values, or you can calculate each value per value.

  <br /><br />

  <h3>Some modifications you can make to see what happens is changing "val = val.Trans(0,A,B);" to "val = val.Trans(1,A,B);".</h3>

  <br /><br />

  This changes the start position in the parts you wish to transform. Also take note that the transform method will terminate sooner, because the parts will most likely be out of range -/+.

  <br /><br />

  You can change the starting position to what ever you like to see the effect for your self. Set it 3, or even 5.

  <a id="cparts"><h1>Creating A number in parts.</h1></a>

  In order to create a number you start with a value that is <h3>NaN</h3>. Which stands for <h3>Not a Number</h3>.

  <br />

  You then can do all manipulation operations, or <h3>split</h3> by "a", and "b".

  <br />

  In order to get a fraction, or number back you add the parts back together using methods <h3>calc</h3>, or <h3>calcF</h3>

  <br />

  <code>
    var val = NaN;

    val = val.split(1,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);
    val = val.split(2,1);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  We create the square root of 2. Using this split sequence.

  <br /><br />

  You can split into any number you like per part.

  <br /><br />

  Now lets say you wish to continue this splitting sequence to the end. Instead of doing a bunch of split operations. You are best to use the transform operation.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(2);
    }

    function B(x)
    {
      return(1);
    }

    val = val.split(1,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  In this example we split the first part as a=1, b=1.

  <br /><br />

  Then we transform the rest of the parts as a=2, b=1 using function A and B.

  <br />

  Then we add it together with the <h3>calc</h3> Method.

  <br />

  This makes the square root of 2.

  <br /><br />

  You can change this however you like. You can create any irrational number you like using this.

  <a id="irrational"><h1>Irrational Numbers.</h1></a>

  An irrational number is a value that can never be solved to it's exact value.

  <br /><br />

  An irrational number is something that looks like this: 1.01001000100001.

  <br /><br />

  Which we can clearly see what the pattern is. As it is 1 followed by one more zero per place value.

  <br /><br />

  Because of this pattern. We can make the number bigger forever without any repeating digits.

  <br /><br />

  You can split irrational numbers into smaller parts. You can also add together irrational numbers using per smaller parts.

  <br /><br />

  But the digits in the number never repeat. For example PI to a billion digits: <a href="https://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt" target="_blank">Link</a>.

  <br /><br />

  Irrational numbers are created when you measure something that gets a tiny bit bigger each time in reference to say another number.

  <br /><br />

  The most basic example is a circle. The circles outside distance gets slightly bigger than the distance across per bigger circle.

  <br /><br />

  This means you are going to get a different number each time. The farther down the decimal place per bigger circle. AS the two lengths change in ratio as you go bigger down the decimal place.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return( 6 );
    }

    function B(x)
    {
      return( 1 + (x * 4) + (x * x * 4) );
    }

    val = val.split(3,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  The above example calculates the number PI per additional part Rally quickly.

  <br /><br />

  This is much different than the physical measurement. As we add per part together to create the number.

  <br />

  <h2>The golden ratio.</h2>

  The golden ratio is a very fascinating irrational number as each part is as small as it possibly can be per part.

  <br /><br />

  All parts are exactly a=1, b=1. It is considered the most irrational number because of this.

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(1);
    }

    function B(x)
    {
      return(1);
    }

    val = val.Trans(0,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <h2>Square roots.</h2>

  Every square root is related to that of the golden ratio. Here is a table of every square root.

  <br /><br />

  <table border="1">
    <tr><td colspan="2">&radic;1</td><td>_</td><td colspan="2">&radic;2</td><td>_</td><td colspan="2">&radic;3</td><td>_</td><td colspan="2">&radic;4</td><td>_</td><td colspan="2">&radic;5</td><td>_</td><td colspan="2">&radic;6</td><td>_</td><td colspan="2">&radic;7</td><td>_</td><td colspan="2">&radic;8</td><td>_</td><td colspan="2">&radic;9</td><td>_</td><td colspan="2">&radic;10</td><td>_</td><td colspan="2">&radic;11</td><td>_</td><td colspan="2">&radic;12</td><td>_</td><td colspan="2">&radic;13</td><td>_</td><td colspan="2">&radic;14</td><td>_</td><td colspan="2">&radic;15</td><td>_</td><td colspan="2">&radic;16</td><td>_</td><td colspan="2">&radic;17</td><td>_</td><td colspan="2">&radic;18</td><td>_</td><td colspan="2">&radic;19</td><td>_</td><td colspan="2">&radic;20</td><td>_</td><td colspan="2">&radic;21</td><td>_</td><td colspan="2">&radic;22</td><td>_</td><td colspan="2">&radic;23</td><td>_</td><td colspan="2">&radic;24</td></tr>
    <tr><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td><td>_</td><td>A</td><td>B</td></tr>
    <tr><td>1</td><td>0</td><td>_</td><td>1</td><td>1</td><td>_</td><td>1</td><td>2</td><td>_</td><td>2</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>2</td><td>3</td><td>_</td><td>2</td><td>4</td><td>_</td><td>3</td><td>0</td><td>_</td><td>3</td><td>1</td><td>_</td><td>3</td><td>2</td><td>_</td><td>3</td><td>3</td><td>_</td><td>3</td><td>4</td><td>_</td><td>3</td><td>5</td><td>_</td><td>3</td><td>6</td><td>_</td><td>4</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>4</td><td>5</td><td>_</td><td>4</td><td>6</td><td>_</td><td>4</td><td>7</td><td>_</td><td>4</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>8</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
    <tr><td>0</td><td>0</td><td>_</td><td>2</td><td>1</td><td>_</td><td>2</td><td>2</td><td>_</td><td>0</td><td>0</td><td>_</td><td>4</td><td>1</td><td>_</td><td>4</td><td>2</td><td>_</td><td>4</td><td>3</td><td>_</td><td>4</td><td>4</td><td>_</td><td>0</td><td>0</td><td>_</td><td>6</td><td>1</td><td>_</td><td>6</td><td>2</td><td>_</td><td>6</td><td>3</td><td>_</td><td>6</td><td>4</td><td>_</td><td>6</td><td>5</td><td>_</td><td>6</td><td>6</td><td>_</td><td>0</td><td>0</td><td>_</td><td>7</td><td>1</td><td>_</td><td>8</td><td>2</td><td>_</td><td>8</td><td>3</td><td>_</td><td>8</td><td>4</td><td>_</td><td>8</td><td>5</td><td>_</td><td>8</td><td>6</td><td>_</td><td>8</td><td>7</td><td>_</td><td>8</td><td>8</td></tr>
  </table>

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return(8);
    }

    function B(x)
    {
      return(7);
    }

    val = val.split(4,7);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  In this example we calculate the square root of 23.

  <br /><br />

  Also you can calculate the golden ratio as the square root of <h3>0.5+&radic;1.25=1.618033988749895</h3>.

  <br /><br />

  You have probably realized by now there are many different ways to line up per A(part) to B(scale) part. As "B" is the scale going to each "A" part.

  <br /><br />

  However there is a method in which you square the remaining part to find the best A to B per part.

  <br /><br />

  Doing this allows you to solve the patterns to all irrational numbers no matter how they are generated per part.

  <br /><br />

  This includes <h3>sine, cosine, tangent, x to y root, logarithms, and even PI</h3>.

  <br />

  Even numbers you create per digit such as 1.01001000100001. Which the irrational pattern is obvious.

  <br /><br />

  <h2>The Natural logarithm.</h2>

  <table border="1">
    <tr><td colspan="2">Natural log.</td></tr>
    <tr><td>A</td><td>B</td></tr>
    <tr><td>2</td><td>1</td></tr>
    <tr><td>1</td><td>1</td></tr>
    <tr><td>2</td><td>2</td></tr>
    <tr><td>3</td><td>3</td></tr>
    <tr><td>4</td><td>4</td></tr>
    <tr><td>5</td><td>5</td></tr>
    <tr><td>6</td><td>6</td></tr>
    <tr><td>7</td><td>7</td></tr>
    <tr><td>8</td><td>8</td></tr>
    <tr><td>9</td><td>9</td></tr>
  </table>

  <br /><br />

  <code>
    var val = NaN;

    function A(x)
    {
      return( x );
    }

    function B(x)
    {
      return( x );
    }

    val = val.split(2,1);
    val = val.Trans(1,A,B);

    val = val.calc();

    console.log(val.toString());
  </code>

  <br /><br />

  The natural log is another good example. As you can see this is similar to that of our square roots, and the golden ratio. With one slight difference. Each part is +1 from before.

  <br /><br />

  <h3>Each of these numbers relate to each other. Think of this as the golden ratio to the square, and then to natural log. In which PI is like a spiral stir case squared.</h3>

  <br /><br />

  If you really do understand, and really work it out. Then you can line up any number to it's pattern.

  <br />

  <h2>At the smallest scale.</h2>

  The Golden ratio is the sub structure to all other numbers. Including all irrational numbers.

  <br /><br />

  The smallest split out of a number is a=1, b=1. Which is the golden ratio. Adding all a, and b together. Is added the same way as the Fibonacci numbers per smaller part.

  <br /><br />

  Each Fibonacci number divided by a prior Fibonacci number forums the golden ratio per a=1, b=1. In perfect equilibrium.

  <br /><br />

  All numbers can be split into parts then added back to their smallest fraction. By adding all A, and B the same way as the Fibonacci sequence.

  <br /><br />

  Which is why any of this works at all. So the Fibonacci sequence is used to add per part together for all numbers. While the golden ratio is a direct 1:1 relation to the whole.

  <br />

  <h2>Rational Vs Irrational.</h2>

  In theory if we could store a infinite number of digits.

  <br />

  All rational numbers can be split to 0 parts remain. Then added back to smallest fraction using <h3>calcF</h3>.

  <br />

  Irrational numbers can be split forever into smaller parts and will never hit 0.

  <br /><br />

  Computers have a limit for the number of digits we can store. So making the determination between the two is hard.

  <br /><br />

  We can say a number is irrational if the final split before 0 is at the end of the accuracy of a floating point number in the computer.

  <br /><br />

  The other method is calculating it in A to B ratio in to a pattern.

  <br /><br />

  It is possible to determine one from the other even with limited digits.

  <a id="dpate"><h1>Periodic patterns.</h1></a>

  Division has some useful characteristics.

  <br /><br />

  1. Such as algorithms that find, and translate recurring (periodic) patterns quickly in data with a single calculation.

  <br />

  2. Generating fun random looking sequences that repeat infinitely periodically.

  <h2>Periodic pattern explained.</h2>

  IF you already know what periodic division pattern is. How it happens in different number bases differently. You can skip to the examples: <a href="#dpat">link</a>.

  <br /><br />

  Division creates periodic patterns when you divide a number that does not divide evenly out of the number of digits per place value.

  <br /><br />

  The next place value is 10, so we subtract one making it 10-1=9. When we divide any number by 9 it will create a remainder that is the same going in and out across the number forever.

  <br /><br />

  <table border="1">
    <tr><td>1&divide;9</td><td>0.111111111111111</td></tr>
    <tr><td>2&divide;9</td><td>0.222222222222222</td></tr>
    <tr><td>3&divide;9</td><td>0.333333333333333</td></tr>
    <tr><td>4&divide;9</td><td>0.444444444444444</td></tr>
    <tr><td>5&divide;9</td><td>0.555555555555555</td></tr>
    <tr><td>6&divide;9</td><td>0.666666666666666</td></tr>
    <tr><td>7&divide;9</td><td>0.777777777777777</td></tr>
    <tr><td>8&divide;9</td><td>0.888888888888888</td></tr>
  </table>

  <br />

  You can make the fractions smaller. You can change 3&divide;9 to 1&divide;3. Which is the same fraction.

  <br /><br />

  What is happening is that we have ten possible digits per place value. We have 0,1,2,3,4,5,6,7,8,9.

  <br /><br />

  Thus anything divided by the last digit creates a indivisible remainder that is the same across the number forever.

  <br /><br />

  The next palace value is 10*10=100, so 100-1=99. Any two digits divided by 99 will repeat forever across the number as it is indivisible.

  <br /><br />

  23&divide;99=0.23232323232323

  <br /><br />

  The next palace value is 100*10=1000, so 1000-1 is 999. Thus any three digits divided by 999 will be indivisible.

  <br /><br />

  719&divide;999=0.719719719719719

  <br /><br />

  You can make any number you like that is indivisible. Thus creates a number pattern using division that is recurring, and periodic.

  <br /><br />

  <code>
    var val = 3 / 9;

    console.log(val);
  </code>

  <br /><br />

  In this example you can try it out your self. You can also change 3&divide;9(3 / 9) with every value you come up with that is indivisible.

  <br /><br />

  However division pattern relates to the number of digits you are using to display your value in per place value.

  <br /><br />

  <code>
    var val = 3 / 9;

    console.log(val.toString(3));
  </code>

  <br /><br />

  In this example the fraction 3&divide;9 works out as 0.1. This is because we are dividing the number up in place values of 3 per place value. Which is what <h3>toString(3)</h3> does.

  <br /><br />

  This is called changing the number base from base 10 to base 3. Instead of each place value being in 10 per place value. It is in place values of 3.

  <br /><br />

  This means we have three digits instead of ten. Thus in three digits 1&divide;3 is perfectly dividable as one third = 0.1.

  <br /><br />

  Changing the number of digits we use in a number per place value changes what is divisible between the number of digits.

  <br /><br />

  However even base three has the following indivisible values.

  <br /><br />

  As the first place value is 3. So 3-1=2.

  <br />

  And the second place value is 3*3=6. So 6-1=5.

  <br /><br />

  <table border="1">
    <tr><td>1&divide;2</td><td>0.111111111111111</td></tr>
    <tr><td>1&divide;5</td><td>0.012101210121012</td></tr>
    <tr><td>2&divide;5</td><td>0.101210121012101</td></tr>
    <tr><td>3&divide;5</td><td>0.121012101210121</td></tr>
    <tr><td>4&divide;5</td><td>0.210121012101210</td></tr>
  </table>

  <br />

  For example half of something can never be dividable out of thirds per place value. However half of ten digits is 5, so a half is 0.5.

  <br />

  So it does not matter what the number of digits you use are. You get the same problem. You end up with 50% divisible numbers, and 50% indivisible numbers. Even if you used base 60 numbers.

  <br />

  Don't worry so much about divisibility of place values in a number system though. Since you can split these types of numbers into parts. Then add the parts together into smallest fraction with <h3>calcF</h3>.

  <br />

  <code>
    var val = 3 / 9;

    val = val.splitAll();
    val = val.calcF();

    console.log(val.toString());
  </code>

  <br /><br />

  This way you do not have to worry about these messed up types of numbers.

  <a id="dpat"><h2>Creating a division pattern.</h2></a>

  To create a new division pattern you use the <h3>Pattern</h3> data type.

  <br />

  <code>
    var pat = new Pattern("31415",10);

    console.log(pat);

    var fract = pat.getFract();

    console.log(fract.toString());
  </code>

  <br /><br />

  We chose the pattern 31415, using out of ten digits. Thus we use the method <h3>getFract</h3> to get the smallest fraction.

  <br /><br />

  We can get more complex than this if we like.

  <br /><br />

  <code>
    var pat = new Pattern("DAMIAN",24);

    console.log(pat);

    var fract = pat.getFract();

    var val = fract.valueOf();

    console.log(fract.toString());

    console.log(val.toString(24));
  </code>

  <br /><br />

  In this example I encode my name into a division pattern. AS you can see the pattern is displayed first. Then fraction. Then value in base 24.

  <br /><br />

  You can encode things like this if you like. When I display the value my name is 0.DAMIAN<div style="display:inline-block;color:#FF0000;">DAMIB</div>.

  <br /><br />

  It gets cut off at DAMIB the second time. The last digit that should be an A gets rounded up to B, because it is the last digit of accuracy in the floating point value.

  <br /><br />

  IF you do not specify the number base. The pattern data type will default to binary. Since numbers are binary in the computer by default.

  <br /><br />

  <code>
    var pat = new Pattern("1011");

    console.log(pat);

    var fract = pat.getFract();

    var val = fract.valueOf();

    console.log(fract.toString());

    console.log(val.toString(2));
  </code>

  <br /><br />

  It is fun working with numbers in different divisible parts.

  <br /><br />

  However you have to remind yourself that it is all in binary place values. Even though we can round stuff off, and divide by different place values.

  <br /><br />

  <h2>Finding the division pattern.</h2>

  <br /><br />

  Lets say you wish to find what the periodic pattern of a fraction, or number is.

  <br /><br />

  <code>
    var f = new Fract(711,911);

    var val = f.valueOf();

    console.log(val.toString(2));

    console.log(f.toString());

    var pat = f.divP();

    console.log(pat.toString());
  </code>

  <br /><br />

  You start by creating a fraction. You then call the operation <h3>divP</h3>. Which divides the value in binary. It finds the two points that equal the same remainder. Then creates the pattern.

  <br /><br />

  In the example code. The first output is the value of the fraction in binary. The second output is the fraction. Then last output is the division pattern before any recurrence.

  <br /><br />

  Assuming you wish to find the division pattern of a value. You then get the fraction of the value then call <h3>divP</h3>.

  <br /><br />

  <code>
    var val = 711 / 911;

    console.log(val.toString(2));

    var f = val.getFract();

    var pat = f.divP();

    console.log(pat.toString());
  </code>

  <br /><br />

  Now all of this is done in binary by default. You can actually pass the number base you want to <h3>divP</h3>.

  <br />

  This will then force division pattern in other number bases like base 10.

  <br /><br />

  <code>
    var f = new Fract(711,911);

    var val = f.valueOf();

    console.log(val.toString());

    console.log(f.toString());

    var pat = f.divP(10);

    console.log(pat.toString());
  </code>

  <br /><br />

  And lets say you wish to convert to a base 10 pattern from just the number value.

  <br /><br />

  <code>
    var val = 711 / 911;

    console.log(val.toString());

    var f = val.getFract();

    var pat = f.divP(10);

    console.log(pat.toString());
  </code>

  <br />

  <a id="fract"><h1>Fraction data type.</h1></a>

  Fractions are useful for values that are periodic. See the section on Periodic patterns: <a href="#dpate">Link</a>.

  <br /><br />

  Such values should be avoided if possible by storing the fraction instead, or splitting such numbers into parts. Then adding the parts back to a fraction.

  <br /><br />

  However the fraction data type is not useful for numbers that are a infinite pattern of parts. This is because such values can never be a finite value. See the section Irrational numbers:  <a href="#irrational">Link</a>.

  <br /><br />

  In binary. Lots of decimal values become un-dividable in place values of two. See the following documentation: <a href="https://docs.python.org/2/tutorial/floatingpoint.html" target="_blank">Link</a>.

  <br /><br />

  Such values can be converted into two values that divide to the value without error. Which is what the fraction data type does.

  <br /><br />

  We can store decimal numbers as fractions, and then add them.

  <br /><br />

  <code>
    var f1 = new Fract(1,10);
    var f2 = new Fract(2,10);

    //Add the two fractions.

    f1.x += f2.x;

    //Display the result.

    console.log(f1);
  </code>

  <br /><br />

  Now normally adding 0.1 with 0.2 would create a floating point error. However it does not this time.

  <br /><br />

  You can multiply, add, and subtract. Such values without any errors as the fraction data type.

  <br /><br />

  Each fraction has a <h3>x</h3>, and <h3>y</h3>. <h3>x</h3> is the numerator, and <h3>y</h3> is the denominator.

  <br /><br />

  This form of arithmetic is preferred in applications that require extremely high accuracy with very little impact on performance.

  <br /><br />

  Now adding 0.1, and 0.2 regularly as follows will result in error.

  <br /><br />

  <code>
    var f1 = 0.1;
    var f2 = 0.2;

    //Add the two numbers.

    f1 += f2;

    //Display the result.

    console.log(f1);
  </code>

  <br /><br />

  The <h3>reduce</h3> method splits the fraction into parts then adds the parts back into the smallest fraction.

  <br /><br />

  <code>
    var f = new Fract(31415,10000);

    //Display fraction.

    console.log(f.toString());

    //Smallest fraction.

    f = f.reduce();

    //Display the result.

    console.log(f.toString());
  </code>
</body>
</html>